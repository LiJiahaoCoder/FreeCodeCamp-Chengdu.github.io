{"pages":[{"title":"活动时空","text":"","link":"/activity/index.html"},{"title":"社群伙伴","text":"","link":"/community/index.html"},{"title":"联系我们","text":"微信服务号 QQ 群","link":"/contact/index.html"},{"title":"精彩瞬间","text":"","link":"/gallery/index.html"},{"title":"撰写文章","text":"添加文章 多媒体文件上传图片、视频、PDF、PPT 等二进制文件上传必须在本地编辑！ Front-matter 规范（点右下角按钮复制模板） title: # 文章主题（翻译成英文后设为本文件的文件名） date: # 开篇日期 updated: # 修订日期 categories: # 分类名应为一个首字母大写的英文单词 # 每级分类对应一级目录，写在本文件的文件名前面 tags: # 与内容相关的更多标签 authors: # 原作者们的 GitHub 账号 original: # 文章出处链接 toc: true thumbnail: # 封面图片","link":"/write/index.html"},{"title":"发起活动","text":"多媒体文件上传图片、视频、PDF、PPT 等二进制文件上传必须在本地编辑！ Front-matter 规范（点右下角按钮复制模板） title: # 活动主题（翻译成英文后设为本文件的文件名） date: # 发起日期 categories: - Activity # 二级分类：Salon、Workshop 或 Conference tags: # online 或 offline # 与内容相关的更多标签 toc: true # Activity meta description: # 活动简介 start: # 活动开始时间 end: # 活动结束时间 address: # 线下活动地址（市州、区县、路街、楼栋） links: 报名: # https://jinshuju.net/f/xxxxxx mentors: # 讲师、教练们的 GitHub 账号 workers: # 组织者、志愿者们的 GitHub 账号 partners: # 合办方、场地方、赞助方 # Attachment meta photos: - # 第一张为活动封面图 - # 第二张开始为活动结束后上传的现场照片 files: - # 活动结束后上传的 PDF、PPT 等非纯文本文件","link":"/activity/launch/index.html"}],"posts":[{"title":"Hello Hexo-Wiki !","text":"Generate this Web-site by just one command: npm init hexo-wiki CDC/OWS \\ --theme Icarus --plugins hexo-permalink-pinyin --remote https://github.com/FreeCodeCamp-Chengdu/FreeCodeCamp-Chengdu.github.io.git","link":"/hello-hexo-wiki/"},{"title":"3RD 共享生活方式空间","text":"为企业员工提供工作 8 小时外的具有社交、娱乐功能的社群互动平台，将音乐、体育、生活美学、文化 IP 融入其中，打造企业员工专属的兴趣 x 社交 x 实用美学的生活方式社区。","link":"/partner/3rd-slss/"},{"title":"阿里云 ACE 成都同城会","text":"我在青城山巅、峨眉云端，还有那四姑娘山间，期待所有成都技术爱好者的到来！ACE 成都同城会带你畅游美景，尝遍美食，享尽云计算的魅力，让我们一起云海弄潮！","link":"/partner/ace-cd/"},{"title":"紫荆谷众创空间","text":"紫荆谷众创空间（上海）于 2017 年 12 月 29 日在上海宝山区纬地路正式开园落地，该众创空间总面积达 3500 平方米，共有 2 层，集国际联合办公、孵化空间、创业服务、创业投资、创业导师培训工作室，打造创业环境一流、创业氛围和谐的新一代国际孵化器和加速器。不仅如此，紫荆谷众创空间细节之处还体现了国际化的要素，概念设计单位 Lifestyle Creating 是拥有国际视野的顶尖设计公司，成功开发并打造了新天地及诸多新概念商业地产项目。同时紫荆谷众创空间运营团队也都拥有丰富的国际化运作模式的专业背景。未来运营团队将结合技术资源、专业导师指导、全球市场接入、产业化落地、投融资服务等领域，为全世界的创业项目提供专项的垂直加速运作，帮助创业者突破发展瓶颈，将“紫荆谷”打造成为国家科技创新的“东方硅谷”，将“紫荆谷+”打造成为传统产业创新的高端平台。","link":"/partner/bauhinia-valley/"},{"title":"创客+ 咖啡","text":"","link":"/partner/cd-ckplus/"},{"title":"乡愁故事馆","text":"天华社区乡愁故事馆是由桂溪街道天华社区居委会主办，桂溪街道办事处支持，爱有戏社会工作服务中心运营的公益性社区营造项目。 天华故事馆以“文化艺术”作为社区营造的切入，建立生活与文化艺术之间的桥梁关系；深度发掘社区地域文化特质，推进人文、特色社区建设；搭建平台，激活辖区资源参与基层社会治理，激活辖区企业与个人，参与社区公共事务。让不同乡音、不同肤色、不同职业和谐共融，培育社区社会资本，建立有活力的自组织，持续开展在地文化生产。 开展项目青年导演计划组建微电影社团，自编自导自演。邀请著名作家莫然、腾讯视频签约导演高书雷、本土笑星棒棒娃赵艺等人参与指导，开展剧本创作及拍摄技术教习。社团首部反应当代都市代际冲突与和解的微电影正在拍摄中。 天华曲艺荟特邀哈哈曲艺社将精彩的传统曲艺带到社区，居民在家门口不仅能享受到高质量的文化演出，更有机会与演员作零距离的交流。曲艺荟激发了居民对在地民间文化的兴趣与关注，推动本土文化的复兴与传承，营造多彩公共生活。 天华读书会由社区文学爱好者组成的居民自组织，线上线下常态化开展阅读与文化交流活动，丰富多彩的主题吸引了社区老、中、青、幼各年龄群体的参与。不定期邀请社区能人举办讲座沙龙，开展文学作品的征集与发布。 戏剧工作坊每周五晚，戏剧爱好者在专业老师的带领下进行表演练习，妙趣横生的环节让参与者在爆笑中过足戏瘾，在飙戏中提升演技。通过戏剧学习增强人与人之间的连接，共享互助理念，孵化以戏剧为核心的公益团队。 方志文化进社区联合成都市地志办，开展方志文化讲座与读书会，解读成都的悠久历史，探讨历史表象背后流淌在成都人血液里乐观向上的生活态度，让蓉漂触摸成都的历史年轮，更加了解成都、热爱成都，传承巴蜀文明，发展天府文化。 梦想之家艺术工坊废弃的瓦楞纸箱，承载了个人生活的记忆，也象征着乡愁的传递。居民在紧张忙碌的工作之余，进行天马行空的创作，打造梦想中的家。这些纸屋经过澳籍艺术家的重构，现身成都•蓬皮杜国际艺术双年展。 你好邻居公益挑战以新颖活泼的公益挑战赛，让参与者身体力行感受公益力量。拉近人与人的距离，增加心与心的温度，宣传义仓互助理念，倡导健康生活方式。 艺术家工作坊邀请外籍艺术家陈业亮、本土艺术家陈建军、杨然等，举办公共艺术工作坊，串联起社区与社会公共文化资源的纽带，建立生活与艺术的连接，打通居民私人空间与公共空间的边界。","link":"/partner/cdth-storyevents/"},{"title":"成都谷歌开发者社区","text":"https://chinagdg.org/p/gdg-chengdu/","link":"/partner/gdg-cd/"},{"title":"freeCodeCamp 社区行为准则","text":"为了营造、维护良好的公益技术社区环境，更好地服务广大开发者，特立此《社区行为准则》。 禁止的行为 发布非技术类商业营销推广（软文广告、集赞分享、拼团秒杀等） 传播未经证实且引起恐慌的消息 发起缺乏事实根据的论战，乃至人身攻击 性别歧视、性取向歧视、性骚扰 侵犯知识产权，违反开源协议 宣扬违反《中华人民共和国劳动法》的用工制度（诸如 996、克扣社保等） 其它违反国际公约、《中华人民共和国宪法》及中国其它法律法规的行为 凡触犯以上禁令，各平台管理员[1]有权直接删除违规内容、清退违规人员，恕不警告！ 需审核的行为 公司招聘请联系各平台管理员[1]，在【FCC 成都社区】微信服务号统一发布推文，并在各群群发推广 推荐的行为 技术疑难请详述问题场景、运行环境、尝试过程，并附上代码/报错截图 技术、公益类活动可联系各平台管理员[1]，在【FCC 成都社区】微信服务号统一发布推文，并在各群群发推广 本准则即日起开始试行，如有任何修改建议，可直接发起 Pull request。 1.如 微信群小助手 panky 账号 ↩","link":"/profile/code-of-conduct/"},{"title":"关于 freeCodeCamp 成都社区","text":"原文链接：https://github.com/FreeCodeCamp-Chengdu/FCC-chengdu 什么是 FCCfreeCodeCamp（简称 FCC）是由美国人 Quincy Larson 发起的开源项目，截止 2018-02-03，在 Github 上获得 29+万 Star（教育类排名第一）。有长达 1600 小时的课程， 并且是基于浏览器、课程免费、证书免费、结合了游戏化闯关的乐趣。FCC 是一个在 160 多个国家和 2000 多个城市的拥有与 1000k+ 开发者的社区。 2016 年 4 月，由 DevEco （晋剑 + Miya）将 FCC 引入中国，并举办了 2000+ 开发者参与的在线全民编程活动，到目前为止，已成功举办了 100+ 场 Coffee & Code / 编程黑客松 / 编程静修日等活动。在 FCC China ， 有 20+% 的女性加入到了社区学习、提升编程能力。 FCC 中国 2017 年度总结 FCC 成都社区FCC 成都社区, 成立于 2016 年 6 月，是一个非营利性的公益性技术社区，是由一群热血有志青年爱好者，利用个人业余休息时间组建而成的技术社区，目的是为了搭建一个友好的交流、学习、互助的社区，帮助成都市众多的开发者，技术爱好者提升个人技术能力。社区致力于做西南地区首个有温度与情怀的技术社区，鼓励人人皆可编程实现个人梦想。 FCC 成都社区成立以来做了那些事情大型活动FCC 成都社区 React 技术专场交流活动 2017 成都首届 Web 前端交流大会 新耀杯 Code for City 黑客松大赛 历史活动 序号 日期 主题 形式 1 20160609 线下活动开启，宣布社区成立 编程讨论 2 20160703 携手编程-成都社区主页初版 动手编程 3 20160911 结对编程的理念 个人分享 + 结对编程 4 20161106 Console 的九大命令 + 学习路线分享 个人分享 5 20161119 Git 的使用与个人简历制作 分享 + 编程 6 20161204 Chrome 开发者工具全解 个人分享 7 20161217 结对编程 - 保龄球积分 + FizzBuzz 结对编程 8 20161231 一个平凡程序员的自述 + CSS 布局那些事 个人分享 9 20170115 JSpace Plane 小游戏 分享 + 编程 10 20170212 BootStrap + xMemory 家用云服务器 个人分享 11 20170305 半程黑客松 - 春季 编程黑客松 12 20170318 Bitmap & Sort + 技术文档导读 个人分享 13 20170402 React + 虚拟 DOM 个人分享 14 20170415 HTTP 与 RESTful API + GraphQL 个人分享与讨论 15 20170429 编程的思想 —— 解决现实生活中的问题 分享与引导 16 20170506 全球开发者关系大会（成都分会场） 直播观影 + 现场分享 17 20170521 Python + Django 快速搭建 Blog 编程指导 18 20170603 Game of Life. React? 个人分享 + 结对编程 19 20170618 半程黑客松 - 夏季 编程黑客松 20 20170624 WebAssembly 微信群问答式交流 21 20170702 程序员如何提高职业竞争力 + 程序员创业 & 项目管理 个人分享 22 20170715 DevOps 从理论到实践 + 敏捷四把刀 分享讨论 23 20170730 社区主页改造 结对编程 24 20170806 编程静修日 自习、交流 25 20170812 浅谈如何提高工作效率 + 现场答疑 个人分享 + 现场答疑 26 20170827 H5 在线编辑器工具开发详解 个人分享 27 20170910 TypeScript 在项目中的应用 个人分享 28 20170924 有趣的 Three.js + 逐步在 Docker 中构建 CI 流程 个人分享 29 20171021 Jetbrains 插件开发入门 + 一小时入门 Web 应用开发 个人分享 30 20171105 用算法解决实际问题 + 前端实用算法串烧 个人分享 31 20171119 2017 成都 Web 前端大会 大型交流活动 32 20171210 编程道场 个人分享 + 结对编程 33 20180120 Code for City 黑客松 编程比赛 + 路演 + 主题分享 34 20180311 《我是谁：没有绝对安全的系统》观影会 观影 + 系统开发安全科普 35 20180331 React 技术专场交流活动 大型交流活动 + 现场招聘 36 20180513 《重温经典-黑客帝国》 观影 + 特效开发科普 37 20180526 跟点融和咕咚聊聊软件架构与认证 个人分享 + 现场答疑 38 20180602 大前端的动态化与可用性建设 分享 + 现场答疑 倡导人人皆可编程活动龙泉洪安中学普及编程 为什么是 FCC 成都社区来做这些事情在成都众多的技术大会、技术分享活动当中，很多的活动以技术分享为幌子，做着产品推广与宣传的事情，这导致了成都 IT 圈子技术分享的氛围越来越差，大家参与分享的热情越来越低。 FCC 成都社区的众多小伙伴，一致认为是时候为这座热爱的城市做一份自己的贡献了，社区提出所有活动全部免费参加、嘉宾分享内容中广告零容忍，成立嘉宾分享内容审查团队，确保每一次分享都是 100% 的干货。 FCC 成都社区的小伙伴们一直明白社区所肩负的使命，带动成都 IT 圈子技术交流的氛围，让更多的技术牛人帮助到更多的开发者，让成都成为全国 IT 行业的先锋，让成都吸引更多 IT 人才蓉漂。进入更多的校园普及更多的次的编程知识，倡导人人皆可编程，让成都这座城市未来充满无限可能。 FCC 成都社区 18 年规划是什么 走进更多校园，普及人人皆可编程思想帮助更多的孩子们。 继续坚持做好两周一次的【Coffee and Code】的结对编程活动、编程道场活动，一对一指导开发者提升个人技术能力。 做好季度技术专场活动，让成都众多 IT 公司加入其中进行分享，带动成都 IT 圈子技术分享的热情。 做好 2018 成都 Web 前端交流大会，让国内一线技术大咖来到成都，给成都众多开发者带来国内一线开发公司的技术心得与经验。 联合成都众多大型 IT 公司，做好 2018 编程马拉松活动，让成都的众多开发者进行技术火花的碰撞。 外部媒体对 FCC 成都社区的报道与采访四川电视台报道四川电视台黑客松报道 成都市高新电视台报道（6 分 53 秒处）2017 成都 Web 前端交流大会 四川财富广播 FM94.0 采访FCC 成都社区：“人人皆可编程”，以独特的方式为城市带来美好改变 四川日报报道揭秘“黑客马拉松”：喝 6 瓶红牛、24 小时里只睡 2 小时","link":"/profile/about/"},{"title":"社区参与指南","text":"《公益技术社区的术与道》 术 线下技术社区的优势主要在于线下技术活动 线下技术社区的成就主要以一次次活动来体现 个人、公司对社区的贡献也主要以一次次活动为单位 一个活动是怎样的？首先体现在它的宣传文案上 一篇宣传文案可以是一篇博客文章 title: # 文章主题（翻译成英文后设为本文件的文件名） date: # 开篇日期 updated: # 修订日期 categories: # 分类名应为一个首字母大写的英文单词 # 每级分类对应一级目录，写在本文件的文件名前面 tags: # 与内容相关的更多标签 authors: # 原作者们的 GitHub 账号 original: # 文章出处链接 toc: true thumbnail: # 封面图片 一篇博客文章又可以附带自定义元数据 title: # 活动主题（翻译成英文后设为本文件的文件名） date: # 发起日期 categories: - Activity # 二级分类：Salon、Workshop 或 Conference tags: # online 或 offline # 与内容相关的更多标签 toc: true # Activity meta description: # 活动简介 start: # 活动开始时间 end: # 活动结束时间 address: # 线下活动地址（市州、区县、路街、楼栋） links: 报名: # https://jinshuju.net/f/xxxxxx mentors: # 讲师、教练们的 GitHub 账号 workers: # 组织者、志愿者们的 GitHub 账号 partners: # 合办方、场地方、赞助方 一次活动的反馈可直接在活动博文下方进行 建议：社会化评论框 捐助：支付二维码 一次活动的总结文字可以就近写在同一篇文章中 现场照片、演示文稿也可放在同级同名文件夹，并用附加元数据关联 photos: - # 第一张为活动封面图 - # 第二张开始为活动结束后上传的现场照片 files: - # 活动结束后上传的 PDF、PPT 等非纯文本文件 一场演讲的演示文稿也可以是一篇博文 title: Hello World slidehtml: true 社区贡献统计基于现代静态网站生成器的二次开发能力实现 https://fcc-cd.dev/activity/ https://fcc-cd.dev/community/ 道 团队的运作模式负责人自上而下的领导 社区的运作模式社群自下而上的生长 开源软件运动现代社群的最成功探索 类 GitHub 平台技术型社区的最佳协作工具 版本控制记录成长点滴，杜绝胡乱删改 开源政务透明、财务公开 Issue, Milestone & Project任务安排、缺陷管理、进度跟踪 Fork & Pull request人人皆可发起、参与活动 公益技术社区就成了一个开源文档项目 开源运动的一切最佳实践、基础设施 皆可为线下社群所用 文献翻译、工具开发不但本身可以开源项目的模式运作 也可同时做成工作坊活动 https://github.com/freeCodeCamp/news-translation/blob/master/Contributing.md https://fcc-cd.dev/activity/workshop/hexo-web-app/ https://fcc-cd.dev/activity/workshop/nodejs-web-crawler/ 战 安装基础软件Windowschoco install nodejs-lts git Mac OS Xbrew install node 创建网站项目npm init hexo-wiki ~/Desktop/FCC \\ --theme NexT \\ --plugins hexo-generator-slidehtml \\ --remote https://github.com/FCC/FCC.github.io.git 配置更新服务branches: only: - hexo language: node_js node_js: - lts/* cache: directories: - node_modules before_install: - export TZ=${TIME_ZONE} install: - npm install script: - npm run build - cd ${FOLDER} - git init - git config user.name ${UID} - git config user.email ${EMAIL} - git add . - git commit -m \"${MESSAGE}\" - git push --force --quiet https://${TOKEN}@${GIT_URI}.git master:${BRANCH} Enjoy your Community!","link":"/profile/guide/"},{"title":"freeCodeCamp 成都社区大事记","text":"本文是 freeCodeCamp 中国社区在首届 2050 大会团聚时水歌代表成都社区做的汇报 星星之火 2016 年 6 月始 余煊 (@Yasic) 连续主持 3 场技术沙龙 燎原之势 2016 年 11 月始 姜姜 (@jiangyuzhen) 接过负责人重任 首次主持技术沙龙便遇上技术宅 水歌 (@TechQuery) 欣然加入 FCC 成都从此步入快速成长期 精彩的 小型技术分享 每半月一次雷打不动 刘博兄 (@too) 开的 拾级咖啡也成了我们第一个长期根据地 小型黑客松、编程静修日等创新活动也相继吸引了 AK (@Akagilnc)、书香 (@demongodYY) 等加入组织者团队 炉火纯青 2017 年 10 月 青松 (@Heqingsong) 与姜姜偶遇，办一场【成都 Web 前端大会】的想法不谋而合 虽首次举办大会，但伴随着更多小伙伴的加入，特别是青松沟通、联络、协调、执行的有力，11 月 19 日便惊艳了成都 Web 开发界 2018 年 1 月 20 日 AK 趁热打铁，迎难而上 有惊无险地完成了首次 FCC 中国【Code for City 黑客松大赛】 在 视频直播、商业合作方面做出不错的探索与尝试 也发掘了会务达人 小山 (@HillChen3)、设计小牛 王波、文案高手 民成 (@Dean266) 2018 年 3 月 31 日 青松 再接再厉，匠心独运 【React 专场技术交流大会】办成了 主题分享、现场招聘相得益彰的新型活动 也为 微信公众号-招聘专栏的建立铺平了道路，奠定了 FCC 在 成都 IT 社招领域的优势地位 至此，青松众望所归，顺利完成 组织者团队壮大后的首次 换届 百炼成钢 倩玉 (@Lmagic16) 厚积薄发，开创 微信公众号-技术周刊 民成 首当其冲，在团队壮大后第一个非负责人主办小型沙龙，而且是 IT 观影、编程入门相结合的新形式 王波、佳琪的 UI 设计沙龙也在筹划…… 水歌一直向往的【JavaScript 全栈技术大会】也获得了 NodeParty 创始人 小芋头君 (@xinyu198736)的授权","link":"/profile/history/"},{"title":"编程大学 —— freeCodeCamp.org","text":"FCC 成都社区校园行 认识编程 程序是什么？ 做一件事的流程（算法）、材料的规格（数据结构）和 结果的预期 程序是一种“说明文” 程序 = 数据结构 + 算法 编程语言又是什么？ 用英文单词、数学符号描述程序，再用编译程序翻译成计算机能懂的 0 和 1 英语、数学很好才能编程？ 初级工程师 —— 逻辑 > 数学 > 英语 逻辑：多数应用开发重在描述程序的前因后果 数学：多数应用开发早期不需要复杂计算 英语：计算机词汇比较简单直白，中学英语 + 翻译工具足以应付 学编程有什么好处？ 学习编程很酷的一点是，你会同时获得两个专长。一个专长是计算机科学和编程，另一个是需要你来编程的那个专门领域。除非你是编译器作者，否则你总是会有自己的专门领域。 —— Rich Hickey，Clojure 语言发明者 女生不适合搞 IT ？ 姓名 成就 轶事 艾达·拜伦 世上首个程序员 大诗人拜伦之女 海蒂·拉玛 3G 通讯创立者 好莱坞女星 葛丽丝·霍普 首个编译器作者 bug 词义提出人 玛格丽特·汉密尔顿 软件工程创立者 阿波罗登月软件开发负责人 王小云 MD5、SHA-1 加密算法破解者 山东大学女博士团队 科班没上只能去培训班？ 互联网最不缺的就是技术学习的资料、平台 收费课程才靠谱？ 要相信全球开放社群的力量！ 认识 freeCodeCamp 全球最大的公益编程学习平台，致力于帮助人们从零基础成长为合格软件工程师 在线网站https://freecodecamp.org 注册用户：全球 300+ 万 全球网站 Alexa 排名：超越同类商业平台 Udacity GitHub 源代码：全球星标第一 Medium 专栏：全球最大 YouTube 频道：编程类最火 全球 7 个全职员工靠着社群捐款，与千千万万业余贡献者一起，完成了这个壮举！ 线下社群 FCC 城市社区遍布世界各地 FCC 中文社区https://chinese.freecodecamp.org 英文编程在线课程翻译 英文编程语言学习指南翻译 英文优秀技术博客翻译 英文优秀技术视频翻译 中文技术学习论坛 FCC 成都社区 https://fcc-cd.dev 活动丰富 技术分享会 结对编程/翻译工作坊 黑客马拉松 代码直播 社群活跃 半月度小型技术活动 不定期中型技术活动 年度大型技术会议 友军众多 开源社：COSCon（中国开源年会）主办方 开源工场：SOSConf（学生开源年会）主办方 成都 Google 开发者社区 成都 Linux 用户组 重庆前端社区 NodeParty 基金会 个人案例 加入我们 吃瓜群众 运营团队","link":"/profile/university-for-programming/"},{"title":"SKFI 中韩未来革新孵化器","text":"","link":"/partner/skfi/"},{"title":"华为云 HDZ","text":"HDZ 是 Huawei Developer Zone 的英文缩写，是华为开发者生态面向全球开发者建立开放、创新、多元的开发者社区组织。致力于帮助开发者学习提升、互动交流、挖掘机会，推动 ICT、互联网等产业生态的建立和发展。对云计算、IoT、人工智能、5G、区块链、鲲鹏、昇腾、软件开发与运维、开源等各技术领域感兴趣的开发者、软件工程师、创业者、运营人、产品人、大学生、老师等都可以参与到 HDZ。HDZ 完全由各地 HDZ 组织者、志愿者自发组建和领导，华为公司只按需对 HDZ 社区活动提供必要的方向指导、资源支持、活动支撑等，并为各地 HDZ 组织者提供与全国组织者互动交流的机会。","link":"/partner/hdz/"},{"title":"开源年会成都场丨码农在 1024 技术趴上可以做什么？","text":"可爱的程序猿/媛们： 你好！COVID-19 肆虐后，居家办公后的你感觉如何呢？1024 程序员节即将到来，在这专属于程序猿/媛的节日，有没有想出来和大家见见面，到现场和小伙伴们面对面畅聊开源、编程话题呢？ 在此，非常诚挚地邀请你参与成都线下的 1024 技术 Party，用你的开源项目及热情来和大家一起愉快地玩耍吧！ 我们的活动有哪些玩法呢？且看我“报菜名”~👇 听演讲 —— 今年 2 天 5 城联动，大咖云集~ 中国大陆最具影响力的开源年度盛会 2020 年 10 月 24 ~ 25 日 程序员节 实时直播 北京、上海、深圳、成都、长沙 5 城分会场邀你一起嗨！~ 摆摊摊 —— 开源项目、开源社区、开放社群，尽情展示~ 2018 成都 Web 前端大会 WebCell 展位 2018 成都 Web 前端大会 Deepin 展位 2019 成都 Web 全栈大会 CovScript 展位 吹牛皮 —— 5 分钟即兴闪电演讲，够胆就来~ 2019 成都 Web 全栈大会 CovScript 作者闪电演讲 吃颜饭 —— 汉服、JK、Lolita，女装也可！ TEDxChengdu Live 2020 水歌着汉服闪电演讲 争奖品 —— 直播提问、市集展位、闪电演讲，先到先得~ 水歌“钦定”的 COSCon 抱枕 超精美的 freeCodeCamp 限量款双肩包 FCC 成都社区 Panky 公仔 今年 FCC 成都办三无大会 —— 无收费、无广告、无主咖…… 因为在技术趴体上 —— 人人都是小咖！ 你来就有展位！ 上就有讲台！ 立刻进入官网注册展位吧！ Web 全栈应用分论坛 ECharts、Midway、DevUI 等明星项目 —— 核心成员，在线教学~ 第二天也有 JavaScript 标准委员会中国代表 —— 带你折腾 TypeScript 编译器 freeCodeCamp.org 创始人 Quincy Larson 主题演讲Quincy Larson 于 2014 年创立 freeCodeCamp.org。目前，该开源项目的规模已发展到每月有超过 600 万用户访问，成千上万名志愿者参与贡献。 在本次演讲中，Quincy 将分享如何将一个开源项目从创始人独立运营发展成大型志愿者团队共同贡献。 Quincy 将分享如何确定项目愿景，如何规划路线图，如何构建项目的第一个版本，以及在发布第一个版本之后，如何吸引一些用户参与进来，成为项目的贡献者。 Quincy 将讨论以下方面的策略： 保证项目财务可持续 赋能贡献最多的贡献者 从社区获得反馈，并划分优先级 选择战略合作伙伴 Quincy 还将分享更多他从构建 freeCodeCamp.org 中学到的经验教训。 感受往届氛围 成都 Web 开发者大会 - 品牌官网 2018 成都 Web 前端大会 - 总结 2019 成都 Web 全栈大会 - 图集 2019 成都 Web 全栈大会 - CovScript 参展方","link":"/activity/conference/coscon-2020-chengdu/"},{"title":"React 技术专场交流活动","text":"小伙伴们元宵节快乐！ 既 2017 前端大会 和刚刚谢幕的 黑客松 之后，FCC 成都社区 马不停蹄地开启了新的活动—— React 技术专场交流活动 ，旨在为刚刚燃起来的成都技术氛围再添新彩。 活动信息本次 React 技术专场交流活动 将是一场主要围绕 React 技术的高质量、高标准、高干货的技术分享与交流的活动，同时也是一场行业高度垂直、人才高度集中、明星企业高度集结的一场大型招聘盛会。 类型：技术分享 + 现场招聘 时间：2018-03-31 周六 12:40 地点：成都市高新区天府五街 200 号菁蓉国际广场 7 栋 1 楼主会场 费用：免费 报名：点击这里报名 签到：活动当天凭 签到凭证 进入会场 技术交流嘉宾腾讯云 郭庆 腾讯云 Web 前端工程师，负责云数据库多个产品，长期从事前端框架设计、规范化和工程化工作。 陈津 腾讯云 web 前端架构师，现负责腾讯云 web 前端/node 平台框架设计和研发，曾先后负责 WP/WIN10 QQ，腾讯云诊断 App；擅长混合开发，web 网络问题定位，平时喜欢玩玩音乐。 蚂蚁金服 简念 蚂蚁金服前端工程师，07 年即加入百度成为一名前端工程师。10 年间撸过从活动页面到复杂 SPA 等各种前端项目。 美团 吴浩麟 一线前端工程师，曾就职于腾讯，现就职于美团。专注于 Web 开发，参与过众多大型 Web 项目的构建、设计和开发，喜欢探索 Web 前沿技术。也是 Golang 和音视频技术的爱好者，活跃于 GitHub，ID 为 gwuhaolin，著有《深入浅出 Webpack》一书。 京东 唐超 8 年前端从业经历，京东无线店铺以及装修平台、智慧店铺、海外站、无线店铺\\活动、618 实时大屏等项目中担任核心开发，热爱前端，拥有丰富的前端开发经验，广泛涉猎于 web 端、RN、游戏、动画等不同平台开发领域，对前端大规模复杂应用、电商平台前端架构、性能优化、游戏活动等有丰富的心得和经验，乐于分享 知道创宇 范卿麟 知道创宇全栈工程师，研发平台负责人；8 年软件从业经验，从业务复杂的巨型企业项目到高效迭代的小微创业产品都有深度参与，重度工作爱好者；现专注研发团队效率提升、通用研发平台打造；希望能给大家带来平静和快乐。 神秘嘉宾 88 年狮子男，7 年攻城经验，曾就职于阿里妈妈用户体验中心、后联合创立硅谷某留学创业公司、目前是国内生鲜 No.1 创业公司大前端负责人，他来自杭州、他是慕课网精英讲师、教学视频累计学习人数达到 48.7 万，开创了 Node 系列教学视频的先河，拥有大量开发者粉丝。 活动流程12:40 - 13:00 活动开始签到 现场交流 13:00 - 13:40 腾讯云成都 React 前端架构 & 大数据可视化应用 分享嘉宾：腾讯云 郭庆、陈津 分享内容一：【腾讯云业务 React 前端生态和架构】任何开发团队都遇到团队与项目扩张，代码质量不统一，逻辑复用困难等问题，这次分享主要介绍腾讯云成都团队在基于 React 生态方面的探索和落地实践，包括 React 常用编程模式、自有框架和设计思想以及工程化实践等内容。 分享内容二：【腾讯云基于 React 的大数据可视化应用实践】随着大数据行业的爆炸发展，数据可视化在前端逐渐成为一个比较热门的方向，这次主要分享腾讯云基于 React 在可视化方向上架构的实践，包含可视化组件架构设计，以及可视化编辑架构设计 。 13:40 - 13:50 提问时间13:50 - 14:30 用 TypeScript 开发大型 React 应用 分享嘉宾：美团: 吴浩麟 分享内容：React 通过组件化和虚拟 DOM 简化代码复杂度，TypeScript 通过工程化手段保证大型项目代码的质量，作为前端技术堆中的两大明星，它们可以结合互补用来解决开发大型前端应用的一些问题和难点。 嘉宾将分享美团在开发大型前端应用时使用 TypeScript 和 React 的经验，涵盖构建、性能、代码质量等主题。 14:30 - 14:40 提问时间14:40 - 15:20 React 快乐开发与安全生产 分享嘉宾：知道创宇 范卿麟 React 作为前端开发生态的代表作，围绕其周有着许许多多的技术框架及最佳实践。本次分享将从 React 出发，介绍编码、测试、审计、部署等等阶段中 “快乐开发” 的秘密，以及在开发的过程中所需要注意的安全问题。 15:20 - 15:30 提问时间15:30 - 16:00 现场简历投递环节 招聘企业信息发布 休息 16:00 - 16:40 React Form 指南 分享嘉宾：蚂蚁金服 简念 分享内容：表单处理在前端开发中一直占据重要位置，本次分享以日常开发中各种典型的表单应用场景为例，介绍基于 react 的表单解决方案,并深入介绍 ant design 中 form 模块的实现原理。 16:40 - 16:50 提问时间16:50 - 17:30 ReactNative 开发实践及在京东业务中的运用 分享嘉宾：京东 唐超 分享内容：在分享中嘉宾会对 ReactNative 的技术架构、开发基础进行介绍，让大家有一个全方位的认识,然后将分享该技术在京东项目实战中运用的方案，以及如何进行性能优化等等，对很多问题将会进行具体的分析。 17:30 - 17:40 提问时间17:40 - 18:10 神秘嘉宾分享环节18:10 集体拍照留念&技术分享环节结束18:20 现场招聘环节报名方式方式一：点击这里报名方式二：扫描下方二维码，填写报名信息 活动单位 支持企业特别鸣谢 鸣谢 感谢 合作社区 参与招聘企业 腾讯云、美团、京东、蚂蚁金服、知道创宇 BBD、企鹅医生、乐车邦、ThoughtWorks、麦麦养老 麦客、tap4fun、货车帮、医联、果小美、23 魔方、汇通天下 招聘与商务合作请联系微信: h994154036 社区介绍FCC 成都社区, 即 freeCodeCamp 成都社区。是一个非营利性的公益性技术社区，是由一群热血有志青年爱好者，利用个人业余休息时间组建而成的技术社区，目的是为了搭建一个友好的交流、学习、互助的社区，帮助成都市众多的开发者，技术爱好者提升个人技术能力。社区致力于做西南地区首个有温度与情怀的技术社区，鼓励人人皆可编程实现个人梦想。 如果您想在 2018 年里： 第一时间了解最新高质量的技术交流活动 查看每周一的技术周刊 和成都更多的开发者进行技术交流 随时掌握成都最新明星企业的招聘 让技术大牛带你装逼带你飞 可扫码关注技术社区微信公众号！","link":"/activity/conference/react-conf-chengdu-2018/"},{"title":"【2019 成都 Web 全栈大会】首批讲师来袭！","text":"2019 年刚过一半，就有小伙伴通过各种渠道来问：今年前端大会还有吗？ 很遗憾，没有了…… 但是！ 我们今年办 —— 全栈大会！！知识面拓宽不止一倍！！！ 西南地区的程序员小哥哥、小姐姐们，你们有没有兴奋地搓起小手手呢？ 先来看看一些 FCC 成都社区的新老朋友吧~ 内容剧透《聊聊 Node.js 构建部署时我们要关心的数据》在 DevOps 的时代，构建和部署都已经自动化了。我们可以在构建时和部署时收集一些我们可能要关心的数据，用于以后排错、预警等等。本 Topic 为我在蚂蚁金服做这些数据的收集和实践的一些总结。 死月 蚂蚁金服 Node.js 工程师；Node.js Core Collaborator 之一；《Node.js：来一打 C++ 扩展》作者。 《从 Angular Ivy 认识前端框架》作为新一代的 Angular 渲染引擎，Ivy 对编译器与运行时代码进行了整体重构，在保证编译和运行效率的基础上，实现了全功能按需引入及开发者友好的代码调试支持。这里将从 Ivy 的完整工作流程入手，结合编译器及运行时实现，介绍 Angular 的完整工作流程以及与其它框架的异同分析。 余泽江 ThoughtWorks 咨询师，95 后，Angular 项目的社区活跃贡献者及国内早期 Angular 布道者，主要专注于 Web 前端框架、JavaScript 语言以及 Web 规范相关领域。 《Thoughts In Deno》销声匿迹的 Deno 如今已经如何了？它身世背后的故事是什么？聊一聊我眼中的 Deno，以及我认为值得称赞的设计思想。 满远荣 来自重庆的 IT 难民，刚到成都讨饭吃的伪全栈工程狮。新晋的开源爱好者，Deno contributor，Deno 中国社区发起人。 《城市大脑地图可视化技术实践》 背景 组件库设计 生态建设 最佳实践 陈森森 中国科学技术大学毕业，计算机专业硕士。任职阿里巴巴高级前端工程师；擅长前端自动化、工程化，前端架构方向。目前在参与城市大脑前端项目建设，地图可视化组件库 gas.gl 的核心开发者。 《DevCloud Web Components 实践》Web Components 在华为云 DevCloud 如何落地？解决了什么问题？为什么要选用 Web Components？ 慕阳 曾经在美团、人人网等互联网公司担任前端开发工程师，目前是华为云 DevCloud 高级前端工程师，负责前端架构、技术预研、性能优化，热爱开源，喜欢折腾新技术。 《SoLiD 社交互联数据 —— 万维网之父的数据主权革命》 谢扬 蒸汽记忆创始人，曾任字节跳动 Hacker，领导开发过容器云、WebIDE、知识图谱等多个项目。现在在研发以身份为中心的操作系统，Authing 已服务海内外上千名开发者，托管超过百万用户。 全栈大会只有这些内容吗？ 不，我们今年办两天！~ 还有好多位大咖正在百忙之中为大家准备演讲主题，敬请期待哦~ 成都首届 Web 全栈大会 时间：2019 年 11 月 16~17 日 地点：成都市高新区天府软件园 共创伙伴招募品牌共创换言之，即是我们的赞助商。 我们的需求：现金赞助，或者场地、酒店、餐食、礼品、交通、搭建、设计、印刷、制作等物资或服务。 我们的回馈：全面的品牌广告价值，可能包括：联名主办、专属企业展台、企业资料入袋、企业与观众互动环节等。 体验共创本次活动外场设计有企业产品体验展台、企业招聘展台以及开源项目市集。 我们的需求：良好的企业产品体验展示、企业招聘者、开源项目宣传者 我们的回馈：精准的社区资源、较大的品牌广告价值。 媒体共创除了传统的媒体合作外，还需要新媒体领域的合作。 我们的需求：稿件采写、活动报道与分发、照片拍摄、创意短片策划、动画制作等。 我们的回馈：良好的品牌广告价值。 共创联络人有意者请联系 FCC 成都社区对外合作理事： 余先生","link":"/activity/conference/web-conf-2019-0/"},{"title":"【2019 成都 Web 全栈大会】门票开售！","text":"最近越来越多的小伙伴在问：“全栈大会完整议程啥时出啊？等着买票呢！” 那就准备好你的付款二维码，绝对物超所值哦！~ 【时间】2019 年 11 月 16 ~ 17 日 09:00 ~ 18:00 【地点】成都市高新区天府五街 菁蓉国际广场 7 号楼主会场 【议程】https://web-conf.dev/#2019/ 【报名】http://fcc-chengdu.mikecrm.com/7pG2aOh 【前情提要】https://fcc-cd.dev/activity/conference/web-conf-2019-0/ 第二波主题/* 贺老主题专用占位符 */ 领域 难度 ECMAScript 进阶 JS 最新的 proposal 介绍，包括提案的目的、用例、对开发者的影响、尚待解决的问题、采纳中需要注意的点等。 贺师俊 贺老 360 技术委员会 Web 前端 TC 委员，ECMA TC39 代表，W3C Chinese Web IG 成员。 《蚂蚁前端研发最佳实践》 领域 难度 前端框架、技术架构 入门 前端的发展真是太快了，每个月都会有新技术，大家普遍抱怨“学不动”。大到框架可以选 Vue、React 和 Angular，选了框架之后才会有很多子领域，前端轮子多的说法不是盖的，比如 CSS in JS 就有十多个方案，数据流方案有数十个方案，怎么选？ 然后选择其实对于个人和团队也会不同，个人可以选择最酷的最前沿的，而团队的选择则还需要考虑整体成本、研发提效等，抹平差异，让大家有差不多的项目、差不多的代码、差不多的目录结构等等，每个人切到另一个项目都有种熟悉感。 本次将和大家介绍蚂蚁前端的最佳实践的选择，比如语言、CSS、目录组织、路由、数据流、Mock、微前端、构建工具、组件开发、测试、性能优化等，以及最佳实践的迭代，遇到的问题、挑战和我们的思考。 陈成 蚂蚁金服 - 高级技术专家 花名云谦，入职阿里已有 11 年。之前在淘宝，负责过淘宝首页、宝贝详情、购物车、下单等很多重要业务的前端部分。然后转岗到支付宝，曾负责 SPM、支付宝开发者工具的开发，以及创建了 Dva、Roadhog、babel-plugin-import、Umi 等。擅长的领域有工具、前端框架以及前端性能等，热衷于开源，大家可以在 https://github.com/sorrycc 找到我。 《无服务器计算架构》 领域 难度 Serverless 入门 无服务器计算是云原生架构，使您能够将更多的运营职责转移到云平台，从而提高灵活性和创新能力。无服务器计算让您可以在不考虑服务器的情况下构建并运行应用程序和服务。它消除了基础设施管理任务，例如服务器或集群配置、修补、操作系统维护和容量预置。您能够为几乎任何类型的应用程序或后端服务构建无服务器应用程序，并且运行和扩展具有高可用性的应用程序所需的所有操作都可由您负责。 蒙维 亚马逊 AWS - 高级解决方案架构师 拥有 15 年以上电信级企业应用系统开发、设计和架构经验。擅长分布式和高可用软件系统设计，擅长微服务和无服务器应用架构设计，熟悉 CMMI 和 Scrum 敏捷开发流程，熟悉 DevOps。 “Brand New Things in WebAssembly Post-MVP Standard” 领域 难度 WebAssembly 进阶 WebAssembly 作为一种新的二进制格式，它可以方便地将 C/C++/Rust 等其他静态语言代码快速的“运行”在浏览器中，这一特性为前端密集计算场景提供了无限的可能。不仅如此，基于 WebAssembly 技术，我们可以快速的将基于 Unity 游戏引擎开发的大型游戏快速的移植到 Web 端，这一切都要归功于 WebAssembly 技术带来的前端运算性能的大幅度提升。 WebAssembly 技术现在已经成为 W3C 的标准，众多浏览器厂商已经提供了对其 MVP 版本特性的支持。在 Google IO 2017/18/19 连续三届大会上，谷歌也将 WebAssembly 技术作为重点进行了公开的演讲介绍和推广。 Post-MVP 版本标准更是会对诸如复杂类型引用（如 DOM 对象）、多线程和 GC 等特性提供支持。WebAssembly 技术所带来的、不仅仅局限于 Web 层面的技术变革在未来将变得势不可挡。 于航 PayPal - Web 前端工程师 曾在阿里巴巴本地生活、TapaTalk 等国内外企业工作，现在 PayPal 上海负责 Global GRT 平台相关的技术研发工作；FCC (freeCodeCamp China) 上海技术社区负责人；多次 QCon、GMTC 大会讲师。研究领域主要为前端基础技术架构、 Serverless、WebAssembly、LLVM 及编译器等相关方向。 作为 WebAssembly 技术布道者，2017 年注册成为 W3C 官方 CG 成员，定期参与 CG 组织的各种在线视频研讨会议，在跟进 Wasm 最新发展情况的同时也为 Wasm 的标准化提出自己的建议和意见。2018 年深度参与到 Emscripten 编译器工具链项目的研发工作中，同年出版名为《深入浅出 WebAssembly》的国内第一本 Wasm 技术书籍，为推动国内 Wasm 技术的发展和落地实践做出了微小的贡献。 《基于 Node.js 打造研发团队的瑞士军刀》 领域 难度 Node.js、工作流 入门 不断提高研发效率（快）与提升研发体验（爽）应该是一个团队成长所必需的两个点。团队无论大小，实际工作中总会遇上公司特有的各种重复性工作，这些脏活儿累活儿交给工具去做无疑会极大提高效率。类似我们用到的各种框架会提供 CLI，而面向团队内部工作流以及公司业务的 CLI，就需要我们自己去开发定制了。 我来分享的就是基于 Node.js，打造及持续沉淀一个团队内部工具集 Dev Tools 的过程中，所需要考虑的工具配置、用户配置、守护进程、文件操作、shell 交互、异常处理、优雅退出、团队协作、命令补全等事项，这可以是一个脚手架，也可以是个框架，目的是分享如何高效的打造这个瑞士军刀，让我们更专注去实现军刀的功能！ 陈洋彬 麦麦养老 - 软件研发负责人 在研发团队搭建与管理、技术体系持续演进与渐进增强、团队工作流设计等方面有一定心得和经验。多年服务后端、Web 前端研发及架构设计经验，关注技术的原理与融会贯通，主张编码与工程的专业、规范、极简。 《基于 GraphQL 的业务中台实践》 领域 难度 GraphQL、中台架构 进阶 面对公司内部老旧的权限服务，我们在只有两个开发人力的情况下，大胆依托 GraphQL 的便利性和工程化，通过 CQRS 模式拆解复杂度，形成了一套基于三种技术栈（基于 React + Antd + ApolloClient 的前端交互，基于 TypeScript + Mongoose + ApolloServer 的后台配置，基于 Spring Boot 2.0 Webflux + ApolloAndroid 的接口输出），支持多租户/多模式/高性能/灵活配置/实时生效的，垂直领域的业务中台。在此，我将向大家介绍我们对 GraphQL 的工程实践。 尹吉峰 原贝壳找房基础架构部工程师，多语言爱好者，偏向异步和函数式编程，酷爱原型搭建。 《Rust 语言全栈开发》 领域 难度 Rust、WebAssembly 进阶 使用 Rust 和 Seed，利用 WebAssembly 进行前后端全栈开发，充分利用 rust 的高性能和安全性，开启一种新的应用开发模式。实现无（手写）JS 的全栈开发新体验。 唐刚 Mike Rust 资深开发者，RustCC 社区联合创始人，在 Rust 的应用层面有一定探索。 “Enhanced Privacy with Decentralized Identity” 领域 难度 浏览器扩展、OpenPGP 进阶 Maskbook 是一个浏览器插件，可以让用户在正常使用 Facebook、Twitter 等社交网络的情况下，保护用户的个人隐私。为此，Maskbook 使用了密码学原理（对称加密与非对称加密），帮助用户对他们的数据进行了加密；也使用了许多前端技术来确保去中心化和隐私安全，包括 GunDB（一个去中心化图数据库）、@holoflows/kit （一个自己造的浏览器扩展开发工具包）、ShadowRoot（Web 标准）。 Jack Works Dimension - 现代前端魔法使 共创伙伴十分感谢共创伙伴们多方面的大力支持！也期待更多伙伴加入成都首届全栈大会的共赢共创！ 钻石赞助阿里云计算 金牌赞助（虚位以待） 银牌赞助（虚位以待） 铜牌赞助亚马逊 AWS 主办方FCC 成都社区 协办方四川捷云信通","link":"/activity/conference/web-conf-2019-1/"},{"title":"2018 重庆前端大会","text":"​ 献给前端的少年们前端的少年们，你们是否和我们一样，发现重庆的前端技术交流存在肥沃的土壤？ 是否也渴盼已久，想要一场专属自己的、独一无二的前端技术交流会？ 那你们是否知道， 2015 年，大批热衷前端的开发者，曾共同策划举办了首届重庆前端交流会。 当时，许多行业组织、互联网大牛帮助有志的互联网人才雄起，变得有“前”又有“钱”，找到了奋斗方向。 2016 年，众多重庆前端从业者集结，参加了第二届前端交流会。 不仅奉献了一场技术盛宴，还共同探讨了开发者及初创企业如何在互联网技术浪潮中稳步前进的问题。 如今，经过两年的积累和沉淀，我们理性归来—— 大数据、可视化、区块链…… 2018，我们想和你一起聊聊这些面向未来的黑科技和前端开发之间千丝万缕的关系。同时也借此机会和大家分享职业成长，一起展望更美好的未来。 活动概况 活动主题：2018 重庆前端开发者交流大会 活动时间：2018.08.18 09:00-18:00 活动地点：混沌星球 1687（重庆市渝中区贰厂文创公园 7 号楼 2 楼） 活动目的 前端布道，传播前沿的技术知识 营造氛围，提供更多的交流机会 持续发展，让沉淀和传播更久远 活动定位 传承 —— 让知识和经验得以沉淀，让分享精神延续 交流 —— 提供交流渠道，探讨前沿技术 归属感 —— 凝聚日益壮大的新鲜的队伍 主办方：混沌重庆、孔明科技 年度赞助方：WEWIN 金牌赞助：孔明科技 铜牌赞助： 重庆卓米科技有限公司 重庆常朝科技有限公司 合作媒体： 人邮异步社区 freeCodeCamp 3W 企服 其它赞助：图灵出版社 ​ 活动流程 时刻 议程 09:00 主办方致辞 09:10 孟之杰《DApp 开发入门》 10:05 姜姜姜《一个技术社区的使命》 11:00 唐友华《怎样让薪资 10 年涨超 30 倍》 11:55 午餐、休息、现场招聘、自由活动 13:40 圆桌《给大家的职业成长建议》 14:40 熊洋《如何参与开源项目》 15:35 水歌《Node.JS 与无界面浏览器》 16:30 月影《基于 Canvas 的跨平台绘图对象模型》 17:25 抽奖 17:45 会后自由交流、合影、聚餐 活动嘉宾月影 《基于 Canvas 的跨平台绘图对象模型》 —— 给对 Canvas、跨平台、可视化和国产开源感兴趣的你 对于我们的吴亮——月影大大，是不是早就久仰大名啦！他曾在微软亚洲研究院做过访问学生，先后在金蝶软件有限公司、百度电子商务事业部、盛大创新院任职。并且早在 2008 年，他的《JavaScript 王者归来》一书就由清华大学出版社出版，豆瓣评分高达 7.5！现在，月影大大正在 360 做总监，带领 360 最大的前端团队——奇舞团。 多年来，月影大大致力于 JavaScript 技术和 Web 标准的推广，活跃于国内极有影响力的 JavaScript 专业网站——无忧脚本，并担任 JavaScript 版的版主！ 这样一位业界堪称“大神”的人物，就要来到我们的现场啦。这一次，他的分享主题是《基于 Canvas 的跨平台绘图对象模型》，将会围绕国产开源、跨平台、可视化分享自己的最新观点，热爱前端的你，是不是已经心动了呢？！ 孟之杰 《Dapp 开发入门》 —— 给想要了解、掌握区块链应用开发的你 孟之杰是奇舞团的成员之一，360 区块链实验室成员，前端跨界程序员，技术翻译爱好者，极客。 他在区块链的开发方面很有经验。这次活动，他计划分享有关 DApp 开发入门的干货，帮助前端开发从业者了解区块链应用（DApp）的开发流程，以及如何用前端熟悉的技术开发 DApp。 所以，想要掌握区块链应用开发技能的小伙伴，一定不要错过这次分享噢！ 唐友华 《怎样让薪资 10 年涨超 30 倍》 —— 给有上进心、有进取心，想要努力改变命运的你 他是孔明科技的前端架构师，个人经历可以用“传奇”来描述：本科学习生物专业，与计算机技术没有多大关系；单出于对前端开发的兴趣，他完全零基础自学，并且在没有个人电脑的情况下，进入前端开发行业，并坚持从业 11 年。 他曾先后在新华社、人人网、新浪网、猪八戒网任职。现在的他，从买不起电脑的农村孩子，到有车有房有事业，薪资涨幅超过 30 倍。 2014 年 3 月，他发起了重庆地区的非盈利性质前端技术交流活动，并逐步演变成了现在的重庆前端交流会。 关于如何提升自我驱动力、如何更好地自我认知、如何建立有效的决策机制，以及对前端开发的认识，他有很多思考和感悟，想要和你分享。 水歌 《Node.js 与无界面浏览器》 —— 给喜欢小众话题、热爱自动化测试的你 他现在是 tap4fun Web 前端工程师，FCC 成都、中国社区理事会成员，也是 JavaScript 全栈开发者、开源软件作者、freeCodeCamp 中文社区技术布道师和 jQuery 贡献者。 如果你对自动化测试感兴趣，不妨来听一听他的分享，说不定会发现，他是你的同道中人呢！ 熊洋 《如何参与开源项目》 —— 给想要了解开源世界中那些精彩故事，以及想要作为个人开发者参与其中的你 熊洋是美团前端工程师，Vue 开发组成员，Babel 代码贡献者。 想知道如何参与到世界一流的、有 10 万+关注人数的 Vue.js 开源项目中去吗？如何赢得创始人的认可、受邀加入核心团队，和行业内国际一流顶尖高手一起工作吗？ 这些，他做到了，在这次的分享会中，他会毫无保留地与你分享。 姜姜姜 《一个技术社区的使命》 —— 给零基础但是想要接触新鲜事物、想要了解编程的你 姜姜姜的个人经历，可以用“有趣”+“传奇”来形容：她曾主持过 50 多场婚礼，做过高中数学老师。在接触到 FCC 社区后，她决定从零基础开始，自学编程，从此走上了程序员的道路。 这次分享，热爱体验不同生活方式的姜姜姜将会分享她的那些奇特体验，同时，她也会介绍 FCC 的背景和历史和 FCC 成都社区的发展历程；并且和重庆热爱前端的小伙伴一起，成立 FCC 重庆社区，让对编程感兴趣的同学有机会免费自学。期待一下，接触编程以后，也许你的人生也会变得有趣得超乎你想象噢。","link":"/activity/conference/web-fe-conf-chongqing-2018/"},{"title":"Deno 入门与 Chrome 性能调试","text":"2019 年 6 月 30 日 13:30 ~ 17:30 成都市高新区天益南巷 18 号创客大使馆 JavaScript 前后端的小伙伴有没有被一天到晚填坑而累得没脾气呢？ 想不想学点高端武艺来对 bug 降维打击呢？ FCC 成都社区半月一次的小活动又来了！！！ 主题简介《Deno 初体验》 让我们来了解 Node.js 之父 Ryan Dahl 的新“造物”Deno 背后的动机，来一起学一下别人“学不动的” Deno，从背景及语法再到简单 HTTP 服务入手，畅谈 Deno 的现在和未来。 讲师简介满远荣，前重庆优启科技架构师、前重庆奇燎科技 CTO，现 ThoughtWorks 切图仔。 Deno contributor；Deno 中国发起人、Deno 中文社区站长及发起人；denolib 组织 Member；Deno 生态核心基础库作者和贡献者。 《Chrome DevTools 之 performance》 从浏览器渲染到动画性能调优，让自己写的前端代码渲染性能可控。 讲师简介Helen，爱玩的程序媛，喜欢写代码、玩游戏、架子鼓、马拉松。 她也是 FCC 成都社区核心成员、Vue Beauty 组件库活跃开发者，并在 Google Women TechMaker 2018（成都站）、第 0 届学生开源年会等会议上发表演讲。 课前准备安装 DenoLinux、Mac OS X在命令行终端执行以下命令： curl -fsSL https://deno.land/x/install/install.sh | sh Windows在 PowerShell 中执行以下命令： iwr https://deno.land/x/install/install.ps1 | iex Mac OS X在命令行终端执行以下命令： brew install deno 安装 Google Chromehttps://google.cn/chrome 参考资料 Deno 中文手册 Deno 核心指南 Deno 生态集锦 活动总结由于本次活动的出品人水歌上周经历了重感冒、在公司项目写微信小程序的双重折磨，没能尽早确定活动日期并联系场地方，导致本次场地没有可用的 HDMI 投影仪、智能电视，只能临时用 AK 同学的私人 Zoom 会议室共享讲师屏幕…… 但幸好大家一起把三张大桌子连起来，人手一台电脑地坐一起，反而拉近了人与人的距离，又找回 2016 ~ 17 年在 @Too 的【拾级咖啡】办活动时的那种感觉！ 第一个主题 Deno 乍看 PPT 很简单，但随着满远荣老师的逐步发散，让在座很多 Web 工程师发现 Deno 独特设计的奥妙 —— 小巧的单可执行文件 —— 安装、部署非常简单 开箱即用的 TypeScript 支持 —— 保持 JS 灵活的同时又强健 内置最新 Web API —— 前端同构代码更好移植 依赖包一条 URL 搞定 —— 基于 ECMAScript 模块标准 虽然现在 Deno 标准库尚不完善，但正因为基于 ES module，一个常用功能官方是否提供，甚至有没有官方软件源，都已不再重要，Deno 完全变成了分布式系统。 尽管如此，官方还是希望维护一批由核心开发者维护的高质量常用库，满老师自己开发的 SMTP 工具库就是 Deno 创始人中意的之一，我们也有幸现场跟着老师从零写一遍这个库的核心代码，通过实践来体会 SMTP 协议和 Deno 的简洁。 【注】我事后发现了一个 VSCode Deno 扩展的 bug —— https://github.com/justjavac/vscode-deno/issues/44 紧接着的第二个主题由我们 FCC 成都社区颜值担当之一的 Helen 小姐姐讲解，几张言简意赅的图文 PPT 之后，便直接开始用 demo 程序演示如何用 Chrome 调试器来分析、优化动画渲染性能。 勤于思考的小伙伴们在讲完后提出了多个值得思考的问题，Helen 在会后的活动总结中做了进一步解答。 活动结束时，小伙伴们纷纷表示收获颇丰，但希望动手实践环节能再更易上手些，并通过一些思考题来现场编码，提升动手的参与度。这些建议我们会在和满老师一起准备下期 Deno 活动时充分采纳，敬请期待！","link":"/activity/salon/deno-chrome/"},{"title":"Google I/O 2019 回顾会（成都站）","text":"2019 年 Google I/O 大会已经落下帷幕，今年成都 GDG 的负责人再次奔赴 I/O 大会现场，成都 GDG 的旗帜也再一次飘扬在大洋彼岸。为了把本次 I/O 大会的新技术、新趋势带回给社区，带回给国内的开发者，成都 GDG 社区将在 5 月 25 号举行今年的 Google I/O 大会回顾。本次活动还邀请了在 Google 新加坡公司从事云解决方案以及云机器学习的大牛到场分享，诚邀大家参加！ 面向人群 对技术痴狂、热爱游戏、热衷尝新，且崇尚科技的你 对 GDG 感兴趣的你 活动议题2019 Google I/O 大会回顾嘉宾简介毕强，Web 全栈工程师、应用架构师，成都谷歌开发者社区负责人之一，连续多年奔赴 Google I/O 大会现场。 内容大纲 今年 I/O 大会新产品、新技术的见解 Google 新一代跨平台开发工具 Flutter 的介绍和应用场景解析 Google Cloud Machine Learning workshop嘉宾简介Markku is a Cloud Solutions Architect at Google. He has worked in cloud computing for the past 10 years. Before joining Google, Markku led the cloud architecture of Nokia Siemens Networks’ global business units, and covered APAC as a technology evangelist at Amazon Web Services. He works out of Singapore, and helps developers and customers across APAC and Japan understand how to best use and architect solutions for Google Cloud. Markku is the IoT solutions lead for J/APAC for Google Cloud. Web 与 Chrome 的新进展嘉宾简介水歌，Web/JavaScript 全栈工程师、开源软件作者，freeCodeCamp 成都社区第 4 任负责人、18 年老谷粉、微软 MVP，致力于 Web/JavaScript 标准应用、开源模式推广。 内容大纲 新实现的 Web API HTTP 协议演进 JavaScript 在 V8 引擎中的改进 Google 搜索支持 How to 微数据 Material Design 支持 Dark 模式。 会后资料 《Web 与 Chrome 的新进展》演示文稿 《Web 与 Chrome 的新进展》观众笔记 现场照片 联合出品主办 协办 场地赞助 媒体宣传","link":"/activity/salon/google-io-2019-extended/"},{"title":"结对编程的理念","text":"虽然深藏保利中心高层的【拾级咖啡】不太好找，但依然没消磨大成都地区 15+ 小伙伴参会的决心，成华、新津一类郊区也不是事儿~ 而且，热情的店主也是技术出身，小店安静、惬意的环境，让 Coffee & Code 可谓名副其实了~ 本期的主题是【结对编程】，一种【敏捷开发】的常见模式，也是入门编程的良好方法，很适合 FCC 线下活动 —— 结对编程心得分享 结对编程的正确姿势 主讲人向大家介绍完“结对编程”的基本概念、方法后，让大家分组认领 FCC 成都社区官网的完善任务，在现场实践当天所学的同时，为社区建设添砖加瓦！ 活动过程中大家尽量“老带新”，两两积极讨论、编码，氛围不错。但不足在于活动结束时，仅一半左右的小组提交了代码，其中只有两个小组在 GitHub 上通过 Pull Request 合并回主库。究其原因，我想是 —— Web 前端新人居多、经验不足，改已有代码不知从何下手 大家 Git、GitHub 使用较少，在代码提交、合并方面 概念模糊","link":"/activity/salon/pair-programming-concept/"},{"title":"产品设计与计算机科学","text":"freeCodeCamp 成都社区 2019 秋季第一期沙龙 不少人一直觉得 FCC 只是个“前端社区”，其实 Quincy Larson 创社之初就没做这个限定，只不过 Web 前端对零基础的人最好上手，线上课程才以前端做入门。其实 FCC 中文化伊始，我们就有 Node.JS 后端 、 通用算法 、 计算机科学 、 程序员面试 等课程， 计算机英语教程 也在计划中。freeCodeCamp.org 志在成为计算机教育界的“维基百科”，目前国际站的 Alexa 全球网站排名已超过同类著名商业平台 Udacity.com（优达学城）。 FCC 成都社区也一直秉持“IT 从业者全职业生涯技能提升”的宗旨，让大家在家门口学习各种 IT 互联网行业的知识。本期线下沙龙，让我们一起从产品设计与计算机科学的全局高度，来重新审视日常繁杂的工作，给有志进一步提升的小伙伴一些启发与思考。 主题简介《创业中打造产品品牌和 IP 的区别、方法与效果》相信每一个程序员都有一个自己的产品梦，在工作之余孵化一个自己的项目。不管是从自身价值、工作之余的额外收入还是业余时间创业，都是不错的选择。 讲师简介 何姚含 交互设计师。爱好研究分享产品、设计、用户体验等内容。有个美工人工智能做图产品创始人，前京东高级设计师。 《计算机科学概览》快速计算机科学概览之一（从早起手工计算设备到现代计算机的历史） 讲师简介 书香墨剑（余琦） FCC 成都社区组织者，野生 JavaScript 程序员一枚，现于可好玩乐从事少儿编程平台全栈开发。","link":"/activity/salon/product-desgin-computer-science/"},{"title":"FCC 小姐姐直播教你 Vue 3.0！","text":"【时间】2020 年 8 月 27 日（周四）19:00 ~ 20:00 自 Vue 3.0 开放了源码，开发者最关心的是框架的更新能为带来什么编码优质体验。本次分享将介绍 Vue 3.0 的新特性以及和 2.0 的区别，也会分享做组件库时踩到的坑，让大家可以避免踩雷。","link":"/activity/salon/vue-3-quick-start/"},{"title":"【直播】志愿者贡献平台 PWA 开发实战","text":"【时间】2020 年 9 月 27 日（周日）19:00 ~ 21:00 本次沙龙将为大家直播基于 Headless CMS、Web 标准组件、PWA 和 TypeScript 开发志愿者贡献平台。 入门概念 Headless CMS Web Components 生成项目 Strapiyarn create strapi-app my-project --quickstart WebCell 开发项目 数据结构 任务 Task 贡献 Contribution 评价 Evaluation 后端难点 OAuth 登录 OSS 文件上传 富文本编辑器 API 文档生成","link":"/activity/salon/webcell-strapi-quick-start/"},{"title":"双手编写未来","text":"**freeCodeCamp 成都社区** 走进 **成都七中育才学校** “编程”是什么？编写“程序” “程序”又是什么？做一件事的流程 —— 算法 流程所需材料的规格 —— 数据结构 程序是一种“说明文” 程序 = 数据结构 + 算法 为何要编程？阐述想法，做“甩手掌柜”，让机器帮我们做事 程序“代码”又是什么？代码 = 英文单词（逻辑）+ 代数符号（计算） 为何代码能处理事物？计算机代码是种形式语言、符号系统 能转化为数学计算 数学公式可以描述万事万物 艾达·拜伦 (1815 ~ 1852) 全球公认第一位程序员 计算机科学的半边天多个里程碑都由女性铸就 6 位女性共同为全球第一台公开的电子计算机编程 葛瑞斯·霍普 (1906 ~ 1992) 程序编译器之母，发现了史上第一个 Bug 玛格丽特·汉密尔顿 (1936 ~ ) 软件工程之母 海蒂·拉玛 (1914 ~ 2000) 移动数字通信之母 1980 年代开始，计算机科学领域女性锐减 性别 只影响思维视角，不影响智力 不要妄自菲薄！ 第一份代码选一门直观、通俗的编程语言入门 比如 标记型语言 HTML 再选一个开箱即用的框架和模板 Talk is cheap, show me your Code!李纳斯·托沃茨 (1969 ~ ) 一刻钟学一课全球最大的公益编程学习平台 freeCodeCamp 中文社区 成都社区 QQ 群 微信服务号","link":"/activity/salon/hands-write-future/"},{"title":"Web 前端入门指导","text":"主要流程 FCC 介绍 自我介绍和分享 在 FCC 学习中，遇到困难了吗？小伙伴们帮你解决 前端导航、优质微信公众号推荐，让你对前端更入迷 九个 Console 命令推荐，让 JavaScript 调试更简单","link":"/activity/salon/start-web-front-end/"},{"title":"走近函数式编程","text":"活动简介活动主要是从书香墨剑学习函数式编程的心得体会出发，来谈谈他所理解的函数式编程，并以一个罗马数字转阿拉伯数的例子和大家一起探讨函数式编程的使用以及对我们日常编码的影响，最后大家互相分享对函数式的理解。 活动信息 时间：2019.03.30 14:00 - 17:00 地点：成都市高新区世纪城路 1029 号天华社区乡愁故事馆 活动流程 时刻 内容 14:00 Who are you? 14:10 函数式编程之我知 14:40 函数式编程之我用 16:00 你谈？我谈？共交流 我可以参与？欢迎有一定 JavaScript 基础、对函数式编程有所理解 或 有不同看法的小伙伴~ 活动总结一来到活动现场，乡愁故事馆的文艺气息似乎可以冲淡些技术宅的刻板，为沙龙参会者带来一丝别样的感受。本次沙龙的主讲书香墨剑不但网名文艺，平时也是个话剧爱好者，活动场地也是他亲自选的，果然符合本人气质。 What ?业内人士深知源自数学思想的“函数式编程”抽象晦涩，书香便以川菜经典“回锅肉”的做法来讲解 —— function 煮(肉) { return 水 + 火 + 肉; } function 炒(...食材) { return 油 + 火 + 食材 + 盐; } let 回锅肉 = 炒(炒(切(煮(肉))), 切(蒜苗), 豆豉); 数学函数 层层传递输入输出、不引用外部变量、不改变外部变量 等主要原则一目了然。 但往往概念、原则讲多了，初学者要么云里雾里、要么颠覆三观，不能对新学的思想方法正确认识、合理运用。于是书香便一针见血地来了个“敲黑板”三连 —— 函数式编程只是一个编程范式！ 区别在于对程序的抽象看法； 一段程序里可以存在多个编程范式。 那…… 书香你怎么看？一图胜千言 —— Why & How ?既然函数式编程有这么多好处 —— 方便单元测试 减少外部状态干扰 通过高阶抽象方便阅读、灵活组合 那该怎么用呢？很多人连 JavaScript 数组自带的 map()、filter()、reduce() 都还用不好呢。无妨，我们动手演练一个例子 —— 罗马数字与阿拉伯数字的转换。 规则如下： // 罗马数字与阿拉伯数字的对应 const roman_arab = { I: 1, V: 5, X: 10, L: 50, C: 100, D: 500, M: 1000 }; 罗马数字从大到小排列，并加起来得到最后的结果，只有下列情况除外： I 可在 V、X 前，表减 1（如 IV 表示 4） X 可在 L、C 前，表减 10 C 可在 D、M 前，表减 100 最后我们实现了罗马数字转阿拉伯数字的代码： const romanLetterToInt = letter => { const table = { I: 1, V: 5, X: 10, L: 50, C: 100, D: 500, M: 1000 }; if (table[letter]) return table[letter]; throw Error(\"capacity should be positive integer\"); }; const strSplit = str => str.split(\"\").map(romanLetterToInt); const subtractItem = arr => arr.map((element, index, arr) => index (acc += curr), 0); 以及阿拉伯数字转罗马数字的代码： const table = { 5: [\"I\", \"V\", \"X\"], 50: [\"X\", \"L\", \"C\"], 500: [\"C\", \"D\", \"M\"] }; const intToIString = number => new Array(number).fill(\"I\").join(\"\"); const mergeLetter = (str, numIndex) => { const length = str.length; const headLen = Math.floor(length / 10), tailLen = length % 10; const headerArray = new Array(headLen).fill(table[numIndex][2]); switch (tailLen) { case 9: return headerArray .concat([`${table[numIndex][0]}${table[numIndex][2]}`]) .join(\"\"); case 4: return headerArray .concat([`${table[numIndex][0]}${table[numIndex][1]}`]) .join(\"\"); default: const tailArray = new Array(Math.floor(tailLen / 5)) .fill(table[numIndex][1]) .concat(str.substring(str.length - (tailLen % 5)).split(\"\")); return headerArray.concat(tailArray).join(\"\"); } }; const splitStr = (str, numIndex) => { const index = str.split(\"\").findIndex(ele => ele !== table[numIndex][0]); return index >= 0 ? [str.slice(0, index), str.slice(index)] : [str, \"\"]; }; const mergeStr = (arr, numIndex) => mergeLetter(arr[0], numIndex) + arr[1]; const getRoman = num => mergeStr( splitStr( mergeStr(splitStr(mergeStr(splitStr(intToIString(num), 5), 5), 50), 50), 500 ), 500 ); 再举个栗子本次活动主题较为抽象，主讲者虽尽力借鉴生活中的例子来讲解“函数式编程”的理念，但大家还是比较困惑；加上参会者自带电脑的又比较少，原定的现场动手实践较早结束。于是水歌便上台即兴分享了自己做过的 TDD 习题 —— 基于函数式编程的保龄球算法，让大家更清晰地认识函数式编程的应用范式。 每局比赛每人有十轮投球 每轮共有两次机会来打倒全部十个瓶子 一次打完为“全中”，本轮得分为 10 + 后两球分数 两次打完为“补中”，本轮得分为 10 + 后一球分数 第十轮全中、补中加 2、1 次击球 规则看完，想必全中、补中的事后加分最让人头疼…… 但函数式编程范式却像我们上学解数理化题时“套公式”一样，让计算程序一目了然 —— 每局分数 = 本局第一次击球分数 + 本局第二次击球分数 + 下局第一次击球分数 x 补中系数 + (下局第一次击球分数 + 下局第二次击球分数) x 全中系数 用代码描述如下： // 两数相加 function sum(first, second) { return first + second; } // 补中系数 function isSpare(first, second) { return first !== 10 && first + second === 10 ? 1 : 0; } // 全中系数 function isStrike(first) { return first === 10 ? 1 : 0; } // 每轮分数 function round(this_first, this_second, next_one, next_two) { return ( this_first + this_second + isSpare(this_first, this_second) * next_one + isStrike(this_first, this_second) * (next_one + next_two) ); } 上述代码虽清晰明了，但还有个关键没有解决 —— 未来的分数怎么办？这就需要学习函数式编程的第一难关柯里化来解决： function curry(origin) { // 原函数声明了几个参数 const count = origin.length; // 包装函数 return function wrapper() { // 当前是否已有足够的参数 return count > arguments.length ? // 还差几个，返回一个记住已传入参数的新函数 wrapper.bind(this, ...arguments) : // 够了，执行原函数 origin.apply(this, arguments); }; } 这样我们就可以把击球数一个个填进去，最终合计即可算出总分 —— const curry_round = curry(round), score = []; score[0] = curry_round(3)(7)(3)(4); // 13 score[1] = curry_round(3)(4)(0)(0); // 7 score[2] = curry_round(10)(0)(3)(7); // 20 // 以此类推…… 讲到这儿，台下部分同学频频点头，露出了“原来如此”的笑容~ 活动反馈以下是会后部分同学的建议 —— 编辑器居然没有设置自动保存 不写注释一时爽，一直不写一直爽 其实讲一讲 Redux，对大家理解函数式编程帮助比较大 其实讲一些实用的例子会更好，也更容易理解！ 听了对柯里化理解还不够 罗马数字转阿拉伯数字的例子不错。阿拉伯数字转罗马数字的例子可以不用讲了，比较冗余了。可以加点例子: 如果其中某个函数抛出异常了怎么处理。 参考资料 主讲 PPT 罗马、阿拉伯 数字互转 保龄球计分","link":"/activity/salon/start-functional-programming/"},{"title":"【阿里云】Web 前端工作坊","text":"【时间】2020 年 8 月 15 日（周六）13:30 ~ 17:10【地点】成都天府五街 菁蓉国际广场 2 栋 5 楼少颢厅【设备】自带电脑！自带电脑！自带电脑！ 互动奖品 WebCell 棒球帽 WebCell 主题提问者可获赠一顶 WebCell 棒球帽~","link":"/activity/workshop/aliyun-web-front-end/"},{"title":"FCC 技术翻译工作坊（第一期）","text":"想在 GitHub 给国外某大型开源项目提 issue，你用心编写一段中文，机翻的英文自己读来读去都觉得不通顺，只好放弃贡献大型开源项目的机会…… 公司远程会议上国内外同事讨论得热火朝天，突然有人叫你名字 “What’s your opinion?”，你觉得尴尬指数五颗星，因为他们之前讨论的你只听懂 60%…… 第一次带女朋友出国旅行，出发前你努力练习问路、砍价的常用口语，想要塑造与当地人谈笑风生的男神形象，结果女朋友觉得还是手机里的腾讯翻译君更让她有安全感…… 不要慌，问题不大 7 月 14 日，FCC 成都社区工作坊又来啦，快来约~~ 结对翻译，成为 freeCodeCamp.org 国际社区的开源贡献者，不仅能提升你的英文水平，还能提升你的 Git 操作熟练度。 不管你是什么行业的小哥哥小姐姐，只要你对翻译感兴趣，都可以参加！ 翻译内容freeCodeCamp.org 是一个注册在美国的非营利组织，创立于 2014 年，以“帮助人们免费学习编程”为使命，创建了庞大的完全免费的学习资源。freeCodeCamp 英文社区的成员发布了大量优质文章，分享前端、后端、 Android、iOS、产品、设计、区块链、人工智能等领域的内容，以及学习编程的经历和求职经验，我们一起把这些文章翻译成中文，分享给更多读者。 我们将在 freeCodeCamp 的 GitHub 仓库协作，参与者可以戳 👆 链接提前浏览挑选你想要翻译的文章喔（文章持续增加中^_^）。 工作坊引导者Coding 引导者：水歌freeCodeCamp 成都社区第 4 任负责人、微软 2018~2020 年度 MVP（最有价值专家）、开源社官网开发组组长，主攻 Web/JavaScript 全栈开发，是多个国际开源项目的贡献者、多个原创开源软件的作者。 语言引导者：Miya曾经是 freeCodeCamp 的志愿者，因为热爱非营利组织与教育，现在全职加入了这个团队，担任 Chinese Community Ambassador，是 freeCodeCamp 在中文地区的唯一员工，与团队和贡献者们一起协作推动社区国际化。 活动流程 时段 内容 13:30 ~ 14:00 参与者陆续到场 14:00 ~ 14:20 FCC 国际社区简介，破冰 & 结对 14:20 ~ 14:30 翻译规范简介 14:30 ~ 17:00 结对翻译进行时 17:00 ~ 17:30 成果分享","link":"/activity/workshop/fcc-technical-translation-0/"},{"title":"内容型网站应用一小时实战","text":"freeCodeCamp 成都社区 在线工作坊 #1 学习收获个人、公益组织、创业团队 快速搭建自己的网站，并生成智能机桌面的 App，同时掌控所有数据、轻松迁移。 教程主旨 内容型网站：新闻门户、官方网站、个人博客、维基百科、技术文档 网站应用：基于 Google 力主的 PWA 国际标准，一键生成网站的 App 零基础、零成本、免维护：开源的一键化生成工具、个人免费的自动化云服务 在线课堂2019 年 3 月 24 日（周日晚）20:00~22:00 内容大纲 基础软件安装（课前准备，下附截图） 挑选 Hexo 主题模板（课前准备） 网站项目生成 # 以 GitHub 账号 FCC 为例 npm init hexo-wiki create ~/Desktop/FCC \\ --theme NexT \\ --plugins hexo-permalink-pinyin \\ --remote https://github.com/FCC/FCC.github.io.git 自定义网站配置 配置托管服务 GitHub 账号注册 配置部署服务 写第一篇文章 配置顶级域名 挑选、注册域名 CloudFlare 账号注册 生成独立应用 参考文档 Hexo 官方文档 Git 简易指南 教练团队 主讲：水歌 助教：Akagilnc、Too、姜姜姜、书香墨剑、ing 助教招募 必要技能：熟悉 Windows、Linux 或 Mac OS X 命令行、包管理器、Git 可选技能：用过 Node.JS、Hexo（或其它静态网站生成器） 【附 0】Windows 软件安装图解0. 安装前提Windows 7 / 8 / 10（及同代 Windows Server） 1. 打开命令行 2. 安装包管理器 （复制、粘贴以下命令） Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1')) 【注意】 已经装了同类或同样的软件可以把那个名字删掉，不用重复装 如有软件安装出现问题，可自行下载、安装，优先安装 Zoom 客户端 3. 安装必备软件（复制、粘贴以下命令） choco install -y git tortoisegit nodejs-lts vscode googlechrome zoom 【附 1】Mac OS X 软件安装图解0. 安装前提Mac OS X 10.10 及以上版本 1. 打开命令行 在 SpotLight 里输入“终端”后回车 或从 LaunchPad 里点击“终端”图标 打开的界面如下，可以在这个提示符后面输入命令执行 2. 安装包管理器在终端里粘贴如下命令后，回车执行 /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 界面如下 回车执行之后显示类似如下输出（安装过程中需要回车确认执行安装，有可能还需要输入用户的电脑密码） 如没有报错，看到 Installation successful 字样即表示安装成功！ 注意：安装非常慢、超时等可能与国内网络条件有关，需要参考 macOS 安装 Homebrew 使用国内镜像源安装。（如下图的报错） 如下图的安装失败则需要参考 Mac 上安装 homebrew 的心酸历程 执行 git 的配置命令： git config --global http.postBuffer 524288000 3. 安装必备软件依次执行如下两条命令进行安装 —— brew install node cask brew cask install sourcetree visual-studio-code google-chrome zoomus 【注意】 已经装了同类或同样的软件可以把那个名字删掉，不用重复装 如有软件安装出现问题，可自行下载、安装，优先安装 Zoom 客户端 4. 参考资料 macOS 缺失的软件包的管理器 macOS 安装 Homebrew Mac 上安装 homebrew 的心酸历程 macOS 安装 homebrew 报错 LibreSSL SSL_read: SSL_ERROR_SYSCALL, errno 54 【附 2】Linux 安装最新版 Node.JSFedora/CentOS、Debian/Ubuntu 等主流发行版官方软件源的 Node.JS 版本可能 < 6.3.0，要先安装 NVM： curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash # 或者 wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash 再安装 Node.JS 最新 LTS 版： nvm install --lts 【附 3】科学上网工具 https://github.com/getlantern/lantern https://psiphon.ca/zh/","link":"/activity/workshop/hexo-web-app/"},{"title":"NodeJS 网页爬虫一小时实战","text":"freeCodeCamp 成都社区 在线工作坊 #2 2019 年 4 月 14 日（周日）晚 8 ~ 10 点 加 QQ 群 (466129470) 上课（入群注明课程名） 学习收获一小时内学会用 Node.JS 从多个网站汇总最新本地 IT 活动列表，并了解一些知识点 —— 用 Chrome 调试器分析 HTML 结构 用 Chrome 调试器分析 HTTP 接口 Puppeteer 无界面浏览器操作 JavaScript 最新标准语法 内容大纲 JavaScript 标准项目生成 静态网页抓取 动态网页抓取 数据接口分析 数据分页处理 课前准备请学员务必提前执行以下命令，安装好开发环境！（操作图解） Windowschoco install -y git tortoisegit nodejs-lts vscode googlechrome zoom Mac OS Xbrew install node cask brew cask install sourcetree visual-studio-code google-chrome zoomus 操作要点JavaScript 标准项目生成npm init es-pack ~/Desktop/web-crawler code ~/Desktop/web-crawler 为 Node.JS 定制配置npm uninstall amd-bundle npm install -D \\ @babel/cli \\ @babel/core \\ @babel/plugin-transform-runtime npm install @babel/runtime package.json { \"engines\": { \"node\": \"^6.13.0\" }, \"script\": { \"lint\": \"eslint source/ --fix\", \"pack\": \"babel source/ -d dist/ -s\" }, \"babel\": { \"presets\": [ [ \"@babel/preset-env\", { \"targets\": { \"node\": \"6.13.0\" } } ] ], \"plugins\": [\"@babel/plugin-transform-runtime\"] } } 静态网页抓取安装依赖包npm install jsdom 核心代码source/static.js #! /usr/bin/env node import \"@babel/polyfill\"; import { JSDOM } from \"jsdom\"; (async () => { const { window: { document } } = await JSDOM.fromURL(\"https://segmentfault.com/events?city=510100\"); const list = [ ...document.querySelectorAll(\".all-event-list .widget-event\") ].map(item => ({ title: item.querySelector(\".title\").textContent.trim(), date: item .querySelector(\".widget-event__meta :first-child\") .textContent.trim() .slice(3), address: item .querySelector(\".widget-event__meta :last-child\") .textContent.trim() .slice(3), banner: item.querySelector(\".widget-event__banner\").dataset.original })); console.info(list); })(); 编译并运行npm run build node dist/static 动态网页抓取安装依赖包npm install puppeteer-core @tech_query/node-toolkit npm install fs-match -D 增加项目配置package.json { \"scripts\": { \"install\": \"app-find chrome -c\" } } 首次安装需手动应用配置： npm run install 核心代码source/dynamic.js #! /usr/bin/env node import \"@babel/polyfill\"; import Puppeteer from \"puppeteer-core\"; import { getNPMConfig } from \"@tech_query/node-toolkit\"; (async () => { const browser = await Puppeteer.launch({ executablePath: getNPMConfig(\"chrome\") }); const [page] = await browser.pages(); await page.goto(\"https://juejin.im/events/chengdu\"); await page.waitFor(\".events-list .events-inner\"); const list = await page.$$eval(\".events-list .events-inner\", list => list.map(item => ({ title: item.querySelector(\".title\").textContent.trim(), date: item.querySelector(\".date\").textContent.trim(), address: item.querySelector(\".address\").textContent.trim(), banner: (item .querySelector(\".banner\") .style.backgroundImage.match(/url\\((?:'|\")?(.+)(?:'|\")?\\)/) || \"\")[1] })) ); console.info(list); process.exit(); })(); 编译并运行npm run build node dist/dynamic 数据接口分析 安装依赖包npm install node-fetch 核心代码source/data.js #! /usr/bin/env node import \"@babel/polyfill\"; import { URLSearchParams } from \"url\"; import fetch from \"node-fetch\"; (async () => { const response = await fetch( `https://event-storage-api-ms.juejin.im/v2/getEventList?${new URLSearchParams( { src: \"web\", orderType: \"startTime\", cityAlias: \"chengdu\" } )}` ); const data = await response.json(); console.info(data.d); })(); 编译并运行npm run build node dist/data 数据分页处理传统思路source/data.js import { URLSearchParams } from \"url\"; import fetch from \"node-fetch\"; export default async function (index = 1) { const URL = `https://event-storage-api-ms.juejin.im/v2/getEventList?${new URLSearchParams( { src: \"web\", orderType: \"startTime\", cityAlias: \"chengdu\", pageNum: index } )}`; console.warn(URL); return (await (await fetch(URL)).json()).d; } source/index.js #! /usr/bin/env node import \"@babel/polyfill\"; import crawler from \"./data\"; (async () => { const list = []; for (let i = 0; ; ) try { const page = await crawler(++i); if ((page || \"\")[0]) list.push(...page); else break; } catch (error) { console.warn(error); break; } console.info(JSON.stringify(list, null, 4)); })(); 通过命令输出数据到文件 —— npm run build node dist/ 1> index.json 现代思路source/data.js export default async function* (start = 1) { while (true) { const URL = `https://event-storage-api-ms.juejin.im/v2/getEventList?${new URLSearchParams( { src: \"web\", orderType: \"startTime\", cityAlias: \"chengdu\", pageNum: start++ } )}`; const data = (await (await fetch(URL)).json()).d; if ((data || \"\")[0]) yield { URL, data }; else break; } } source/index.js #! /usr/bin/env node import \"@babel/polyfill\"; import crawler from \"./data\"; (async () => { const list = []; for await (let { URL, data } of crawler()) { console.warn(URL); list.push(...data); } console.info(JSON.stringify(list, null, 4)); })(); Think more… 多源数据去重 定期抓取 展示界面 本地应用打包 服务器部署 【附】样本数据 https://www.huodongxing.com/events?orderby=n&tag=IT%E4%BA%92%E8%81%94%E7%BD%91&city=%E6%88%90%E9%83%BD https://www.bagevent.com/eventlist.html?f=1&tag=17&city=%E6%88%90%E9%83%BD https://www.oschina.net/event?tab=latest&city=%E6%88%90%E9%83%BD&time=all https://juejin.im/events/chengdu https://segmentfault.com/events?city=510100 【附】参考文档 项目创意 DOM API 文档 Node.JS 中文文档 Puppeteer 中文文档","link":"/activity/workshop/nodejs-web-crawler/"},{"title":"AI 学院工作坊 #0","text":"AI 学院与 FCC 成都社区联合出品 一次开放的 AI 深度学习体验，一场解码 AI 更多可能性的讨论。 —— 在这里，数位来自成都的热爱 AI 科技的 Deans 期待与你相遇！ 参会须知 目标群体：软件开发者、会一点点程序设计的人、AI 从业者 免费！自带电脑！！！ 主要流程 AI 学院简介 AI 简介 Python 环境和深度学习开发依赖的安装 实现一个简单的深度神经网络 课前准备建议学员提前执行以下命令，安装好开发环境（操作图解） Windowschoco install -y git tortoisegit python vscode miniconda3 Mac OS Xbrew install python brew cask install sourcetree visual-studio-code miniconda Conda 虚拟环境 与 python 依赖包conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --set show_channel_urls yes conda create -n deeplearning python=3.6.5 -y conda-env list conda activate deeplearning # 中国教育网用户切换镜像 # pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple pip install matplotlib numpy pandas tensorflow==1.11.0 keras -i https://pypi.doubanio.com/simple/ 特别鸣谢 天华社区乡愁故事馆是由桂溪街道天华社区居委会主办，桂溪街道办事处支持，爱有戏社会工作服务中心运营的公益性社区营造项目。 活动回顾我们的主讲 Ethen 老师Ethen 用浅显易懂的语言和实例，像大家介绍了什么叫做 AI、机器学习、深度学习、神经网络。 比如，这是一个假设的，根据面积来预测房价的图，而这条绿线，就是最贴近各个点的一条线，那么其实就可以表现为一个神经元 那么多个因素就可以生成多个神经元，根据我们定义的逻辑就可以把它们组合起来形成多个神经元组成的网络 —— 神经网络 而机器学习的奇妙之处，在于它可以自己去寻找这一层原本需要人类去定义的关系，所以在这里，实际的神经网络变成了下图所示的结构 而机器学习会试着去找出更合理的规则，来让我们的答案更加贴近我们的目标。 最终，我们理解了这几个术语的意义与关系 真的是连完全没有经验的小白都能理解呢，给 Ethen 老师打 call！ 专心思考的参与者们全程无尿点，后续的提问环节也是有大量的小伙伴提出了很有质量的问题，看来大家是真的理解了呢。唯一的遗憾可能就是因为网络不太好没有能跟着实现一遍了吧，后续补上～ 隐藏的角落这位美女提出了相当棒的问题，作为一个不会编程的人，却从数学的角度给出了很棒的建议，建议用距离正确答案的比例差来取代绝对值差，就连 Ethan 老师也是赞不绝口呢！ 下次还要来玩哦希望这次大家玩的开心，下次还要来哦！","link":"/activity/workshop/school-of-ai-0/"},{"title":"AI 学院工作坊 #1","text":"AI 学院 与 FCC 成都社区联合出品 大家复联都看了么？每个英雄都认识的清清楚楚了吧？ 可你知道，AI 也能认识英雄么? 今天，我們要教 AI 做图像识别， 介绍我们的超级英雄给 AI 认识吧。 —— 在这里，数位来自成都的 AI 科技爱好者期待与你相遇！ 参会须知 目标群体：软件开发者、会一点点程序设计的人、AI 从业者 免费！自带电脑！！！提前做好课前准备（见下文）！！！ 主要流程 Python 环境和深度学习开发依赖的安装 图像处理相关概念介绍 图像识别的 Python 实现 实现漫威英雄识别 课前准备请提前执行以下命令，安装好开发环境（操作图解） Windowschoco install -y python miniconda3 Mac OS Xbrew install python brew cask install miniconda Conda 虚拟环境 与 Python 依赖包conda create -n deeplearning python=3.6.5 matplotlib -y conda-env list conda activate deeplearning pip install scikit-image opencv-contrib-python numpy tensorflow==1.11.0 keras \\ -i https://pypi.doubanio.com/simple/ 活动回顾Ethan 老师这次给我们带来了 图片识别 的内容 我们用到了 Google 预先训练好的 inception v3 卷积神经网络，用 2573 张图，训练了一个全连通的神经网络 了解了每张图可以用像素的特征来展示。这里我们用 1280 个参数来表示一张图。 最终在某种准确度上，实现了区分复联里的超级英雄的能力。","link":"/activity/workshop/school-of-ai-1/"},{"title":"微信机器人入门实战 Python & JavaScript","text":"2019 年 6 月 16 日 13:30 ~ 17:30 成都市高新区天益南巷 18 号创客大使馆 基本流程跟着教练一起，实现一个简单的微信机器人 自动通过好友请求 发送信息给指定好友 发送信息给特定群体 拉人进群 你的收获 收获志同道合的小伙伴，锻炼你的思维、动手能力和表达能力 学会用 Python 或 JavaScript 做自己的微信机器人 参与须知 活动免费，自带电脑和你的激情！ 对小白友好，欢迎任何对 coding 感兴趣的小伙伴参与! 课前准备建议学员提前执行以下命令，安装好开发环境（操作图解） 安装包管理器WindowsSet-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1')) Mac OS X/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 如果提示权限问题，请在前面加上 sudo 安装开发环境Windowschoco install -y git python nodejs vscode googlechrome pip install pipenv -i https://pypi.doubanio.com/simple/ # 或 pip3 install pipenv -i https://pypi.doubanio.com/simple/ Mac OS Xbrew install python nodejs brew cask install sourcetree visual-studio-code google-chrome pip install pipenv -i https://pypi.doubanio.com/simple/ # 或 pip3 install pipenv -i https://pypi.doubanio.com/simple/ 项目初始化Pythonmkdir ~/Desktop/WeChat-robot cd ~/Desktop/WeChat-robot pipenv install itchat -i https://pypi.doubanio.com/simple/ Node.JSmkdir ~/Desktop/WeChat-robot cd ~/Desktop/WeChat-robot npm init -y npm set puppeteer_download_host https://storage.googleapis.com.cnpmjs.org npm install wechaty wechaty-puppet-puppeteer puppeteer 参考资料 WeChaty 官方文档 WeChaty 规范示例 FCC Panky 微群管 活动回顾即将开始还没有开始呢，水歌大佬就已经迫不及待的指点迷津了 破冰时间大家各自介绍了自己，希望你们在活动中交到好朋友哦 导师风采学习真是一件开心的事情！ 活动现场我们先从登录和自动回复消息入手 然后给特定好友发消息，再给群组好友发消息 最后学会了如何自动通过好友请求，并且把这个好友拉入指定的群 完结撒花大家都动手敲了一个下午，收获满满吧？下次还要来哦！ 反馈教训事后我们做了反馈调查，小伙伴们提出了一些超棒的建议 对于pipenv和虚拟环境的认识不够，可以做一些说明 现场环境网络比较差 椅子质量有点差（摔） 活动内容本身 节奏希望再紧凑一些 除了按照导师教的做之外，能有一些小挑战，即学习、模仿、思考题的模式 现场采用结对编程的模式，让大家更有互动感，也可以规避一些环境安装的问题 活动完后可以给学员一个发表感受的机会 我们非常感谢这些很棒的建议，并且会应用到下一次工作坊，敬请期待～","link":"/activity/workshop/wechat-robot/"},{"title":"【工作坊】Web 标准组件开发","text":"正在筹划本期工作坊时，就看到 FCC 成都社区的微信群里有小伙伴在苦恼前端技能提升的问题，也有小伙伴想一起开发一个组件库，那你们这次可来对了~ 本期工作坊是水歌在 2019 年 Google DevFest 成都站《Web 组件标准实践》演讲后的首次配套工作坊，可以错过上次，但一定不要错过这次！ 【时间】2019 年 12 月 21 日（周六）13:30 ~ 17:30 【地点】成都市高新区天益南巷 18 号创客大使馆 实践收获 学习 Web Components 标准原生 API 的基本用法 了解 WebCell 如何基于 TypeScript、JSX、Parcel 简化 Web 组件开发 亲手封装一个基于 BootStrap 的通用 Web 组件，现场为开源项目做贡献 实践路线图Step 0 | Web Components 标准简介 Web Components 是一套浏览器提供的新标准 API，用于实现框架无关的 Web 组件。其官方 polyfill 补丁支持 IE 11+，Polymer、Angular、Ionic Stencil 等国际 Web 前端框架已全面应用。 Step 1 | 手写一个 Web 组件只用 Web Components API 来实现一个简单的组件。 Step 2 | 用 WebCell 简化组件 WebCell 是一个基于 Web Components API 的轻量级组件引擎，在保留 Web Components 核心写法的同时，基于 TypeScript、JSX、Parcel 等成熟技术，进一步简化 Web 组件的开发。 Step 3 | 封装一个 BootStrap 组件 BootStrap BootStrap 可谓 CSS 框架时代的开创者，一直被模仿、从未被超越。在同时代的大量同类框架中，现在基本只有它还在持续演进。 在当今基于 Angular、React、Vue 等的 JS 组件库大行其道之时，BootStrap 为何仍有很大的优势？来基于它亲自封装一个通用 Web 组件、开发一个 Web 应用，你就能体会到其设计的独到之处~","link":"/activity/workshop/web-components-development/"},{"title":"【工作坊】文化成都，文言编程","text":"说到中文编程，上了年纪的程序员想必知道易语言、中蟒、周蟒、孔 Caml 等语言，所有支持 Unicode 的现代编程语言也都支持用汉字等非英文字符做标识符（比如水歌参与翻译的 CodeceptJS API）。但在华人 IT 界，中文编程一直争议极大、毁誉参半。不过，两岸四地的华人程序员们，多年来却从未放弃对母语编程的不懈探索。 最近一位在美国卡耐基梅陇大学读书的华人大四学生又新创了一门中文编程语言 —— WenYan（文言），一个月左右的时间便在 GitHub 斩获近一万四千 star！ WenYan 编程语言 但它与上述前辈迥然不同，不再是简单地替换英文标识符、关键字，徒生违和感，而是完全以古汉语的语法行文，再编译为 JavaScript、Python 等主流语言去运行，可谓是真正的用中文去编程！ 不仅如此，作者从一开始便运用开源社区运营手法 —— 英文说明文档、语法规范文档、在线开发环境、本地编辑器插件等一应俱全，甚至还结合《九章算术》等古代数学著作的风格做了代码古籍图片生成器！实乃后生可畏，我大中华复兴有望矣！ 于是乎，生长于中国历史文化名城的 FCC 成都社区也想为中文编程做一点微小的贡献，便有了本期工作坊（这恐怕是全球第一次文言编程线下活动）~ 【时间】2020 年 1 月 12 日 13:30 ~ 17:30 【地点】成都市高新区天府五街 200 号 菁蓉国际广场 2A 栋 9 楼 紫荆谷众创空间 序言夫混沌初开，阴阳分晓。盖两仪化四象，四象生八卦，八卦生无穷，此天地万物之生也。至冯祖降世，悟有无之道，尽天机之正，锻金为骨，化爻为髓，作精妙之仪，御之以电，上可演九章算术，下可推少广方田， 乃开后世之先河。 然则阴阳之道，众人难之，皆欲代之以文，谓之语言。不意甲子之期未至，百家争鸣已然，程式语言之多，繁若《天官》之星宿，奇胜《山经》之走兽。然以文言编程者，似所未有。有奇人 LingDong，宿好文章，且通程式，乃做斯言，行文言编程之事。且承开源之大义，此当吾辈之所以勉励也。 吾辈小子数人，尝创可思摩斯之奥义。结其于文言程式之中，乃凭文法之妙，于方寸之间，创宇宙之万物。行此聚会，以文、程二物会友。固为一乐，并望君能于乐中有所获矣。 内容 简单介绍文言编程的转译源代码，以及与 co3mos 项目的融合 了解文言编程的关键字，熟悉文言编程的语法，写出一个“问天地之好在” (Hello, World!) 在 co3mos 平台上用文言文动手实践一个算法/几何绘画题目 在 co3mos 平台上用文言文做出一个游戏 生成作品文言代码书 示例代码 讲师 余琦 FCC 成都社区 - 核心成员 可好玩乐 - Web 开发工程师 协办 紫荆谷众创空间 紫荆谷众创空间（上海）于 2017 年 12 月 29 日在上海宝山区纬地路正式开园落地，该众创空间总面积达 3500 平方米，共有 2 层，集国际联合办公、孵化空间、创业服务、创业投资、创业导师培训工作室，打造创业环境一流、创业氛围和谐的新一代国际孵化器和加速器。不仅如此，紫荆谷众创空间细节之处还体现了国际化的要素，概念设计单位 Lifestyle Creating 是拥有国际视野的顶尖设计公司，成功开发并打造了新天地及诸多新概念商业地产项目。同时紫荆谷众创空间运营团队也都拥有丰富的国际化运作模式的专业背景。未来运营团队将结合技术资源、专业导师指导、全球市场接入、产业化落地、投融资服务等领域，为全世界的创业项目提供专项的垂直加速运作，帮助创业者突破发展瓶颈，将“紫荆谷”打造成为国家科技创新的“东方硅谷”，将“紫荆谷+”打造成为传统产业创新的高端平台。 参考 https://www.raychase.net/758","link":"/activity/workshop/wenyan-programming/"},{"title":"CodingDojo 编程道场 #1","text":"本期编程道场，FCC 成都联合 Le Wagon 一起在 wework 为大家呈现。提供良好的环境和有趣的知识，最关键是，有最棒的小伙伴们，还在等什么，快来加入我们。 2019/1/20 13:30 ~ 17:30 WeWork：199 东大街，睿东中心 B 座 40F 基本流程针对预先准备的趣味问题，分组探讨解决方案，动手检验，上台展示小组结果。 你的收获 收获志同道合的小伙伴，锻炼你的思维、动手能力和表达能力。 了解并使用 TDD、结对编程的敏捷实践来实现方案。 什么人可以参与编程道场？ 对 TDD，结对编程等敏捷方式有兴趣的小伙伴； 愿意尝试，希望和人交流获取更多灵感的有想法的小伙伴； 想要不断学习提升的小伙伴； 参与编程道场需要什么？活动免费，自带电脑，和你的激情！ 参与编程道场需要有编程基础么？本期编程道场对小白友好，欢迎任何对 coding 感兴趣的小白们参与。 活动流程 时刻 内容 13:35 自我介绍 13:45 主持人介绍编程道场 14:00 编程道场实践与分享环节 17:30 自由交流、反馈、合影","link":"/activity/workshop/coding-dojo-1/"},{"title":"Git 入门及 GitHub Pages 个人主页开发","text":"主要流程 Git 及其常见在线平台介绍、常用功能入门 个人主页开发（非预编译型，托管于 GitHub Pages） FCC 题目答疑、自由交流 重庆前端大会入场券团购动员","link":"/activity/workshop/my-github-pages/"},{"title":"编程道场之结对活动","text":"什么是 Coding Dojo？Coding Dojo 是一个集体学习活动。一些程序员（通常是 15-20 人）在一起编程解决一个程序问题。一边编程，一边互相学习。每个人可以从 Coding Dojo 中学到：解决问题的思路、编程技巧、面向对象设计、演进式设计、结对编程、测试驱动开发、持续集成等等。 流水帐开场由于是到新场地第一次搞活动，负责组织的小伙伴们都提前到了做准备。参加活动的小伙伴们大部分准时到场了，稍微比计划时间晚一点之后，2 点左右主持人 Too 宣布了活动的开始。 先是惯例由 FCC 成都总舵主姜姜姜同学简单介绍社区的情况，然后是每个人的自我介绍，大家建立第一印象。 结对编程活动介绍Too 用了半个小时左右对本次活动内容和安排进行说明，由于考虑到这次到场的小伙伴对敏捷开发和结对编程都比较陌生，所以尝试说得比较详细，对相关术语也尽量解释清楚。为了方便大家建立更直观的印象，Too 和书香一起现场用 cyber-dojo.org 网站进行了演示，使用了比较简单易懂的 Word Wrap 题目。在疑似结对争吵中，两个人演示了结对编程基本的样子；如何做最简单的测试驱动开发；互相交换角色等。这部分时间没控制好超出了计划。 第一个结对环节，采用题目 FizzBuzz随机两两组合结对之后，大家就热火朝天的开始了结对尝试。Too 在现场对各组的观察和询问了解中发现了一些情况： 在介绍演示过程中，忽略了对“红-绿-重构”这一基本动作的强调，部分小伙伴没有完全按照这个来进行练习 对 TDD（测试驱动开发）这种模式的陌生，导致部分小伙伴对第一个测试测什么产生困惑，而有的小伙伴测试和实现代码一起写完才运行测试，这些都影响了对 TDD 好处的感受。 cyber-dojo 的结对编程环境在使用 JS 的严格语法检测下，会有不少报警，不少小伙伴都不太习惯。由于前两个问题都是直接对活动的目的有较大影响，因为主持人不得不多次打断正在互相讨论或编码的大家，进行提醒。 4 点左右，看着大家还是做得不亦乐乎，有点不忍打住。但是本次结对活动的目的是让大家感受和实践结对的技巧，避免在题目上耗费太多时间，所以还是强制大家停下来休息 5 分钟，然后回来一起看看进行的情况。在回顾的过程中，主持人随机挑选了几组结对的小伙伴的代码，按本次结对编程活动的目的进行了说明和评论，指出哪些地方是符合了设想的要求的，哪些是有所欠缺。（所有人一起查看，尽量保持了评论的代码是匿名性） 第二个结对环节，采用题目 Anagrams应该说 FizzBuzz 题目还是比较简单的，重新组对之后，建议了大家尝试更难一点的题目，但是介绍环节和第一个环节的时间已经超出计划比较多了，留给这个环节的时间较少，所以整体来说，这个环节进行的不太顺利，简单抽取了几对小伙伴的代码进行一起回顾之后，就有点匆忙的结束了。 主要的一个问题是，随着题目难度的增加，应该测试什么，和如何拆分任务来达到小步迈进上，普遍缺乏 TDD 经验的小伙伴们大部分被卡住了。 结束还是惯例，收集大家的反馈，然后一起合照之后，大概 6 点左右，结束了今天的活动。看到现场还有结对的小伙伴留下来继续讨论，感觉能激起他们的兴趣，心里挺高兴的。活动后得到的初步反馈是破冰环节不足，导致大家进入状态慢；时间控制没做好，超出计划太多；活动前期说明和准备不足，影响大家在现场的了解和实践。都是对我们活动改进的宝贵意见，其他还有的话还请大家及时反馈，对我们很重要。 参考资料和扩展链接 使用 Python 从头到尾的以 TDD 方式开发一个项目可以阅读Python Web 开发：测试驱动方法 (豆瓣) / Praise for Test-Driven Development with Python 要学习 SOLID 设计原则, 可以阅读”Agile Software Development, Principles, Patterns, and Practices”, 或 “Agile Principles, Patterns, and Practices in C#”. 要学习如何能为其他程序员提供编写整洁代码的反馈，可以阅读 Robert C. Martin 所著 “Clean Code” 要学习如果能够识别代码腐臭来做重构，可以阅读 Martin Fowler 所著 “Refactoring” 要学习如何将难以测试的遗留代码改造为便于测试的情形来编写测试，可以阅读 Michael Feathers 所著 “Working Effectively with Legacy Code” 结对编程的正确姿势，你会了吗？ – ThoughtWorks 洞见 重新思考 Code Retreat - Seaborn Lee - ThoughtWorks 咨询师 如何爱上结对编程 » Topics » 中国软件匠艺小组 告诉你什么叫结对编程！ Atlassian 愚人节视频—在线播放—优酷网，视频高清在线观看","link":"/activity/workshop/pair-programming-demo/"},{"title":"【青铜三人行】外篇之循环与递归","text":"不知不觉青铜三人行已经做了两个月的题了，这次轻松点，看看不一样的吧。 机器擅长的事 —— 重复作为专业的程序猿，经常被行业外的朋友问到，为什么要学习编程？其实，除了掌握技能提高工作效率、甚至成为职业以外。学习编程更重要的是：思维训练。 其实，计算机从一开始就是为了帮助人们解决复杂问题而设计出来的。而在这个过程中，计算机程序的「思考」模型是一个叫“图灵机”的计算模型，图灵机是图灵 (Alan Mathison Turing) 祖师爷模拟人思考而发明出来的。为什么图灵祖师爷要发明图灵机呢？是因为他想要试图以自己和自己周围的天才科学家的思维方式作为人类的具体实例，来抽象总结出一套解决问题的办法。所以说，计算机程序的运作方式其实是一种人类尝试用简单的方式逐步去解决复杂问题的天才的思考方式。 在如今的时代，计算机早已经充斥在我们生活的方方面面，想要更好地进行人机交互，或多或少地我们都需要一些「像机器一样」的思考方式。即使是作为专业程序员，不断培养自己像机器一样思考的思维模式也是必不可少的。 既然要像机器一样去思考，那么不妨从计算机最擅长的事情 —— 重复，开始说起吧。下面是来自 TED-Ed 中「Think like coder」系列课程的第一节，讲的就是计算机的重复 —— 循环。 各种编程语言的循环来看看在实际编程中，不同编程语言的循环写法有什么不同吧！ for 循环Cint jj; for (jj = 0; jj prints \"0, 1, 2, 3, 4, 5, 6, 7, 8, 9, \" printf(\"\\n\"); Java// for loop structure => for(; ; ) for (int fooFor = 0; fooFor 9 System.out.println(\"fooFor Value: \" + fooFor); JavaScriptfor (var i = 0; i","link":"/article/algorithm/loop-and-recursion/"},{"title":"【青铜三人行】二叉树中的最大路径和","text":"每周一题，代码无敌~ 这一次，青铜三人行决定在五一假期期间挑战一道难度为「困难」的题目： 二叉树中的最大路径和力扣 ​leetcode-cn.com 给定一个非空二叉树，返回其最大路径和。 本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。 示例 1输入：[1, 2, 3] 1 / \\ 2 3 输出：6 示例 2输入：[-10, 9, 20, null, null, 15, 7] -10 / \\ 9 20 / \\ 15 7 输出: 42 解题思路因为这次题目相对来说比较困难，因此就以一种思路来说明。 这道题的难点在于，题目中要求取的“任意节点出发”的路径，且不一定经过根节点。导致在如何迭代求取上，陷入了一个比较复杂的境地。 为了求解这个问题，我们需要将题目先简化一下，分步骤完成： 求取某一节点为起始的最大路径和function maxChildrenPathValue(node) { if (node == null) return 0; const leftPathVal = maxChildrenPathValue(node.left), rightPathVal = maxChildrenPathValue(node.right); const maxPathValue = Math.max(leftPathVal, rightPathVal) + node.val; return Math.max(maxPathValue, 0); } 在这一步中，我们递归求取了某一个节点为开始的单边最大路径和，值得注意的是，如果取出来的值是负值，则设为 0，意为「舍弃」掉这条路径。 求取经过某一根节点的最大路径和完成了上一步，我们就可以求取经过某一特定根节点的最大路径和了，即把「某个节点的值」与「左边最大路径和」和「右边最大路径和」相加： function getRootMaxPathVal(root) { const leftMaxPathVal = maxChildrenPathValue(root.left), rightMaxPathVal = maxChildrenPathValue(root.right); return leftMaxPathVal + rightMaxPathVal + root.val; } 遍历求取整颗二叉树的最大路径值有了上面的基础，我们就可以遍历整个二叉树，来求取所有节点的最大路径和，并取出其中的最大值来作为整颗二叉树的最大路径和了，在这里我们用了二叉树前序遍历，并使用了一个全局变量 result 来记录最大值： function preorderTraversal(root) { if (!root) return; const value = getRootMaxPathVal(root); if (value > result) result = value; preorderTraversal(root.left), preorderTraversal(root.right); } 到此我们就可以解出这道题目了，完整代码如下： /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {TreeNode} root * @return {number} */ function maxPathSum(root) { let result = -Infinity; function maxChildrenPathValue(node) { if (node == null) return 0; const leftPathVal = maxChildrenPathValue(node.left), rightPathVal = maxChildrenPathValue(node.right); const maxPathValue = Math.max(leftPathVal, rightPathVal) + node.val; return Math.max(maxPathValue, 0); } function getRootMaxPathVal(root) { const leftMaxPathVal = maxChildrenPathValue(root.left), rightMaxPathVal = maxChildrenPathValue(root.right); return leftMaxPathVal + rightMaxPathVal + root.val; } function preorderTraversal(root) { if (!root) return; const value = getRootMaxPathVal(root); if (value > result) result = value; preorderTraversal(root.left), preorderTraversal(root.right); } preorderTraversal(root); return result; } 优化同样的解题思路下，Helen 发现到在求取某一节点为起始的最大路径和这一步的时候，已经在对二叉树进行遍历了，那能不能直接在一次递归遍历中解出题目呢？Helen 对代码进行了优化： function maxPathSum(root) { let max_sum = -Infinity; function max_gain(root) { if (root === null) return 0; const left_gain = Math.max(max_gain(root.left), 0), right_gain = Math.max(max_gain(root.right), 0); const newPath = root.val + left_gain + right_gain; max_sum = Math.max(newPath, max_sum); return root.val + Math.max(left_gain, right_gain); } max_gain(root); return max_sum; } 代码简洁多了，运行也更快了！你有没有发现两个解法的共同之处和不同之处呢？ Extra最后依然是曾大师的 Go 语言 show time~ func maxPathSum(root *TreeNode) int { var val = INT_MIN(); subMaxPathSum(root, &val); return val; } func subMaxPathSum(root *TreeNode,val *int) int{ if (root == nil) return 0; left := subMaxPathSum(root.Left, val); right := subMaxPathSum(root.Right, val); threeSub := root.Val + max(0, left) + max(0, right); twoSub := root.Val + max(0, max(left, right)); *val = max(*val, max(threeSub, twoSub)); return twoSub; } func INT_MIN() int{ const intMax = int(^uint(0) >> 1); return ^intMax } func max(x, y int) int { if x","link":"/article/algorithm/max-path-sum-of-binary-tree/"},{"title":"【青铜三人行】每周一题@三数之和","text":"哈喽~ 每周一题，代码无敌。欢迎各位继续观看「青铜三人行」的刷题现场。 话不多说，我们进入这周的题目吧： 三数之和给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a、b、c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 例如 // 给定数组 const nums = [-1, 0, 1, 2, -1, -4]; 最初的解法Helen 拿到题目，心想这道题岂不是如同上周的“两数之和”一般？无非就是多加了一个数而已。按照思路，首先暴力举出所有满足条件的三个数，再去重即可，写出了如下代码： function threeSum(nums) { const results = []; for (i = 0; i a - b; const sortedNums = nums.sort(funcSeq); const length = sortedNums.length; const result = []; for (let i = 0; i a - b; const sortedNums = nums.sort(funcSeq); const length = sortedNums.length; const result = []; for (let i = 0; i a - b; const sortedNums = nums.sort(funcSeq); const length = sortedNums.length; const result = []; for (let i = 0; i 0) break; if (num === sortedNums[i - 1]) continue; let lIndex = i + 1; let rIndex = length - 1; while (lIndex str.split(\",\")); } 而 Helen 则从“去重”这一部分上进行了优化，节省了转化成字符串，再用 Set 等数据结构去重带来的额外开销： function threeSum(nums) { const funcSeq = (a, b) => a - b; const sortedNums = nums.sort(funcSeq); const length = sortedNums.length; const result = []; for (let i = 0; i 0) break; if (num === sortedNums[i - 1]) continue; let lIndex = i + 1, rIndex = length - 1; while (lIndex 2) { result = append(result, append([]int{}, 0, 0, 0)) } continue } var remain = 0 - keyi * 2 _, ok := keyCountMap [remain] if ok { result = append(result, append([]int{}, keyi, keyi, remain)) } } } for i := 0; i","link":"/article/algorithm/three-number-sum-algorithm/"},{"title":"【青铜三人行】每周一题@两数之和","text":"哈喽，大家好，欢迎来到青铜三人行的每周一题现场。在接下来的时间里，我们三人（Helen、书香、曾大师）会在每周选择一道编程算法题来完成，和大家一起探讨一下解题的思路。所谓每周一题，代码无敌，欢迎各位小伙伴们一起进入我们的刷题之旅~ 因为个人水平有限，我们的解法不一定是最优的，只是希望抛转引用，分享自己的思路，带动和大家一起练习编程技能。大家有任何建议，也可以通过 bronze_3@163.com 邮箱联系我们~ 话不多说，就进入我们这周的题目吧，它出自 LeetCode 的第一题： 题目给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 解法一拿到题目，Helen 心想，这次题目难度不大。略一思忖，要在数组中找到满足某个条件的两个数，一个双重循环搞定即可： function twoSum(num, target) { for (const index in num) { for (const _index in num) { if (index !== _index && num[index] + num[_index] === target) { return [index, _index]; } } } } ​ //作者：Helen //链接：https://leetcode-cn.com/circle/discuss/5cC2dU/view/p3MA3g/ //来源：力扣（LeetCode） //著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 顺利通过题目！但是效率似乎并不理想…… 解法二接下来就要优化算法，Helen 审视代码，发觉影响效率的主要原因恐怕是在于双重循环所造成的 O(n²) 复杂度。要想提高效率，恐怕就要在一重循环里搞定题目。但如何在一次迭代中找到两个数的关系呢？确实颇费考虑…… 算法领域中，空间与时间通常如同鱼和熊掌一般不可兼得。空间换时间…… Helen 灵光一现，对了，一次迭代中表现两个数的关系，可以在 map 结构中用查找 key 的方式呀。考虑至此，信手写出了第二版代码： function twoSum(nums, target) { const numsMap = {}; for (const index in nums) { numsMap[nums[index]] = index; } for (const index in nums) { const complement = target - nums[index]; if (numsMap[complement] && numsMap[complement] !== index) { return [index, numsMap[complement]]; } } } ​ //作者：Helen //链接：https://leetcode-cn.com/circle/discuss/5cC2dU/view/p3MA3g/ //来源：力扣（LeetCode） //著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 如此一来，时间复杂度减为 O(n)， 速度果然大大提高： 书香作为一个函数式编程的拥护者，平日里对 map、 filter、 reduce 等方法都记在心里。看到这个代码，心想恐怕在循环中对数组的频繁引用是一个可以优化的点，于是利用 JavaScript 中内置的 reduce 方法稍作修改： const twoSum = function(nums, target) { const objNums = nums.reduce((acc, num,index) => { acc[num]=index; return acc},{}); ​ for (let i=0; i","link":"/article/algorithm/two-number-sum-algorithm/"},{"title":"【青铜三人行】每周一题@组合总和","text":"每周一题，代码无敌~ 这次让我们回到算法本身，来探讨一下回溯算法： 组合总和力扣 ​leetcode-cn.com 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明所有数字（包括 target）都是正整数。 解集不能包含重复的组合。 示例 1输入: candidates = [2,3,6,7], target = 7, 所求解集为: [ [7], [2,2,3] ] 示例 2输入: candidates = [2,3,5], target = 8, 所求解集为: [ [2,2,2,2], [2,3,3], [3,5] ] 思路对于这道题来说，最困难的点就在于「candidates 中的数字可以无限制重复被选取」, 这个条件导致了最后结果的集合里面可以选的元素的数量不一定，直接导致了满足条件的可能性组合的数量暴增，给程序的复杂性带来了一定的挑战。 面对这种情况，我们就不得不尝试组合出各种能容纳最多元素的组合。在学习算法的过程中，可以理解到，类似面临这种 「查找最远路径」的问题，最适合的算法场景就是 「深度优先」搜索算法。 回到这个题目当中，我们想要找出所有满足条件的组合，就是要 「从长到短」、「从小到大」尝试所有相加不超过 target 的组合。而在如果遇到组合超过 target 的情况，则回到更 「短」一点的组合尝试其他可能性： 以这道题目的 示例 2 为例： 如图所示，我们从左往右，每次尝试去取到最多元素的可能性，当组合的和大于或等于 target 的时候（等于的时候要记录结果），就返回上一层，尝试新的组合（新的组合的数要比之前的大）。相当于在这里 「剪掉」了后面的可能性，并 「返回」了上一层去尝试。因此这种算法也被称为了 「回溯剪枝算法」。提一下，「回溯剪枝算法」其实就是一种 「深度优先查找」(DFS) 算法。 注意：对于这个题来说，这个算法必须在有序数组中才可以才行，因为数值越大，深度就越有限。 解法了解了思路，我们先来看看 Helen 的解法 /** * @param {number[]} candidates * @param {number} target * @return {number[][]} */ function combinationSum(candidates, target) { const result = []; let tmpPath = [], start = 0; candidates = candidates.sort((a, b) => a - b); function backtrack(tmpPath, target, start) { if (target === 0) { result.push(tmpPath); return; } for (let index = start; index 222 -> 2222 -> 223(合适) -> 23 -> 233 -> 26 -> 3 -> 33 -> 333 -> 36 -> 6 -> 66 ->7(合适) var result [][]int var currCandidate []int func combinationSum(candidates []int, target int) [][]int { sort.Ints(candidates) result=make([][]int,0) currCandidate=make([]int,0) DFS(target,candidates) return result } func DFS(target int,candidates []int) int { if getSum(currCandidate) == target { temCandidate := make([]int, len(currCandidate)) copy(temCandidate, currCandidate) result = append(result, temCandidate) return 0 } else if getSum(currCandidate) > target { return -1 } else { //主要看这里用0代表相同，-1代表已经超过了当前target，1则表示还能继续加 for i := 0; i","link":"/article/algorithm/combined-sum/"},{"title":"【青铜三人行】匹配子序列的单词数","text":"每周一题，代码无敌~ 这次让我们换换口味，讨论一个稍微偏实际一点的问题： 匹配子序列的单词数力扣 ​leetcode-cn.com 给定字符串 S 和单词字典 words, 求 words[i] 中是 S 的子序列的单词个数。 示例输入: S = \"abcde\" words = [\"a\", \"bb\", \"acd\", \"ace\"] 输出: 3 解释: 有三个是 S 的子序列的单词: \"a\", \"acd\", \"ace\"。 注意所有在 words 和 S 里的单词都只由小写字母组成。 S 的长度在 [1, 50000]。 words 的长度在 [1, 5000]。 words[i] 的长度在 [1, 50]。 暴力破解法这周的题目相对简单。从题意上来理解，无非就是 words 数组中每一个单词拿到 S 字符串中去尝试匹配就好。稍微值得注意的是，因为匹配的规则在于不一定是连续子字符串匹配，因此需要考虑每个字母在其中是否全部都存在，Helen 给出了暴力解法： function numMatchingSubseq(S, words) { let count = 0; for (const word of words) { let index = -1, _count = 0; for (const str of word) { _count++; const _index = S.indexOf(str, index + 1); if (_index === -1) break; else index = _index; if (_count === word.length) count++; } } return count; } 书香在同样的思路上，利用 JS 的自带 API ，稍微做了一些写法上的优化，让程序看起来更简短了一些： function numMatchingSubseq(S, words) { const isSubWord = function (s, word) { let pos = -1; for (let i = 0; i count + isSubWord(S, word), 0); } 你看出了其中的相同之处了吗？ 正则表达式匹配既然是字串匹配，自然可以通过正则表达式来完成匹配。书香尝试了这一解法： function numMatchingSubseq(S, words) { return words.reduce((count, word) => { const testReg = new RegExp(word.split(\"\").join(\"w*\")); if (testReg.test(S)) count++; return count; }, 0); } 但是，正则匹配花费的计算资源会更高一些，因此这个解法在题目中的超长字串测试用例中，因为超出时间限制而失败了…… 在这里贴出这段代码，仅作为一种思路的参考。 可不可以不那么暴力？Helen 作为三人行里唯一的女生，自然忍不了动不动就 「暴力破解」的做法 ‍♀️。因此她换了一个不那么暴力的思路，通过将 words 中的单词按照首字母先排序到一个 「桶」中，将数据进行了预处理，然后在字符串匹配其中字符的的时候，就可以从对应的地方匹配了： function numMatchingSubseq(S, words) { const bucket = Array.from({ length: 26 }, () => []); let count = 0; for (const word of words) bucket[word.charCodeAt(0) - 97].push(word); // a 的 Unicode 是 97 for (const str of S) { const list = bucket[str.charCodeAt(0) - 97]; bucket[str.charCodeAt(0) - 97] = []; for (let word of list) if (word.length > 1) { word = word.slice(1); if (word) bucket[word.charCodeAt(0) - 97].push(word); } else count++; } return count; } Extra曾大师的 Go 语言时光，他似乎也很暴力…… func numMatchingSubseq(S string, words []string) int { count := 0 for i := 0; i len(S) { continue } else { for i := 0; i","link":"/article/algorithm/number-of-words-matching-subsequence/"},{"title":"【青铜三人行】删除链表的倒数第 N 个节点","text":"每周一题，代码无敌。这周，「青铜三人行」为你带来了一道关于“链表的题目”。 删除链表的倒数第 N 个节点给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例 给定一个链表: 1 -> 2 -> 3 -> 4 -> 5, 和 n = 2；当删除了倒数第二个节点后，链表变为 1 -> 2 -> 3 -> 5。 说明给定的 n 保证是有效的。 进阶你能尝试使用一趟扫描实现吗？ 力扣 ​ leetcode-cn.com 啥是链表要完成这道题，首先就得了解一下啥是链表？简单来说，链表是一种数据结构，它由一系列离散的节点组成。其特点是，每个节点上除了自己的数据以外，还会有一个或两个指针指向下一个或者上一个节点，使得这些节点可以链起来。 其中，只有指向下一个节点的链表称为单向链表，它只能从前一个节点到下一个节点一个方向来查找其中的节点数据： 而双向链表则拥有两个指针，分别指向之前和之后的节点： 而在 JS 中，这道题目里给我们设定了链表的结构，很明显，是一个单向列表： function ListNode(val) { this.val = val; this.next = null; } 解法一：两次遍历找到对应的节点了解了链表的数据结构以后，这道题就不难解决了。不过题目里有个小小的花招，即要求寻找「倒数第 n 个节点」。因为是单向链表，我们没法倒着寻找节点，因此我们很容易想到先找到整个链表的长度，计算出要找的元素的正向位置，然后再从头遍历，进行删除： /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @param {number} n * @return {ListNode} */ function removeNthFromEnd(head, n) { let node = head, length = 0; while (true) { if (node === null) break; node = node.next; length++; } node = head; if (n === length) return head.next; for (let i = 0; i n) { store = store.Next } p = p.Next i++ } // 删除头节点 if (i == n) { return store.Next } store.Next = store.Next.Next return head } 而在时间和空间上，相当惊人，嗯嗯…… 结尾这周的题目相对来说比较简单，主要是说明了链表的数据结构。链表相对于数组来说，更容易插入、删除其中的节点，而数组比起来则更容易查找到某个节点（想想为什么？）。两个数据结构相辅相成，在不同的应用场景选择合适的数据结构，可以让你的程序运行起来事半功倍哦！ 这次的题目就这样了，欢迎通过 bronze_3@163.com 邮箱联系我们，下周见！","link":"/article/algorithm/remove-nodes-of-linked-lists/"},{"title":"【青铜三人行】每周一题之验证栈序列","text":"先说一个消息，为了方便互相交流学习，青铜三人行建了个微信群，感兴趣的伙伴可以扫码加下面的小助手抱你入群哦！ 青铜三人行小助手（其实是 Helen） 每周一题，代码无敌~ 这次的主题是 「贪心算法」： 验证栈序列给定 pushed 和 popped 两个序列，每个序列中的 值都不重复，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false。 示例 1输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1] 输出：true 解释：我们可以按以下顺序执行： push(1), push(2), push(3), push(4), pop() -> 4, push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1 示例 2输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2] 输出：false 解释：1 不能在 2 之前弹出。 提示 0","link":"/article/algorithm/verify-stack-sequence/"},{"title":"ECMAScript + DOM 骚操作","text":"前一阵有篇传播较广的 Web 技术博文，我看后觉得，作者题为“ES 6”，但有些示例代码却不够 ES 6，且看我一一优化~ 对标文章 中文译文：《记好这 24 个 ES6 方法，用来解决实际开发的 JS 问题》 英文原文：“24 modern ES6 code snippets to solve practical JS problems” 我来优化1. 如何隐藏所有指定的元素？for (const element of document.querySelectorAll(\".your-selector\")) element.hidden = true; 【知识点】 for ... of HTMLElement.prototype.hidden 4. 如何获取当前页面的滚动位置？const getScrollPosition = ({ pageXOffset, pageYOffset, scrollLeft, scrollTop } = window) => ({ x: pageXOffset ?? scrollLeft, y: pageYOffset ?? scrollTop }); getScrollPosition(); // {x: 0, y: 200} 【知识点】（ES 11/2020 特性，略微超纲） ?? 空值合并运算符 5. 如何平滑滚动到页面顶部？window.scrollTo({ top: 0, behavior: \"smooth\" }); 【知识点】 window.scrollTo() 8. 如何获取元素中的所有图像？const getImages = (element = document) => [ ...new Set( Array.from( element.querySelectorAll('img, input[type=\"image\"]'), ({ src }) => src ) ) ]; getImages(); // ['http://fcc-cd.dev/xxx.jpg', 'http://fcc-cd.dev/yyy.png'] 【知识点】 Array.from() input[type=\"image\"] 9. 如何确定设备是移动设备还是台式机、笔记本电脑？const isMobile = \"ontouchend\" in document; console.log(isMobile); 【知识点】 touchend 事件 11. 如何创建一个包含当前 URL 参数的对象？const parseURLData = (raw = location.search) => Object.fromEntries([...new URLSearchParams(raw)]); parseURLData(\"http://url.com/page?n=Adam&s=Smith\"); // {n: 'Adam', s: 'Smith'} 【知识点】（ES 10/2019 特性，略微超纲） Object.fromEntries() URLSearchParams() 若想支持重名参数、参数值转基本类型，请参考 Web Utility 的实现。 12. 如何将一组表单元素转化为对象？const formToJSON = form => Object.fromEntries([...new FormData(form)]); formToJSON(document.forms[0]); // {email: 'test@email.com', name: 'Test Name'} 【知识点】 FormData() 若想支持同名多值、 fieldset 转嵌套对象、参数值转基本类型，请参考 Web Utility 的实现。 14. 如何在等待指定时间后调用提供的函数？const delay = seconds => new Promise(resolve => setTimeout(resolve, seconds * 1000)); await delay(1); console.log(\"1 second later\"); 【知识点】 Promise() 顶层 await 提案 17. 如何获得给定毫秒数的可读格式？const unitISO = [\"Y\", \"M\", \"D\", \"H\", \"m\", \"s\", \"ms\"], patternISO = /[YMDHms]+/g; function formatDate(time = new Date(), template = \"YYYY-MM-DD HH:mm:ss\") { time = time instanceof Date ? time : new Date(time); const temp = new Date(+time - time.getTimezoneOffset() * 60 * 1000) .toJSON() .split(/\\D/) .reduce((temp, section, index) => { temp[unitISO[index]] = section; return temp; }, {}); return template.replace(patternISO, section => temp[section[0]].padStart(section.length, \"0\") ); } formatDate(new Date(1989, 05, 04), \"YYYY年MM月DD日\"); // '1989年06月04日' 【知识点】 Date.prototype.toJSON() Array.prototype.reduce() String.prototype.padStart() 上述函数的核心是 ISO 时间格式，它也是 Date 对象序列化到 JSON 中的标准格式。又因为 ISO 时间总是 0 时区的，所以要事先做好时区偏移，使转出的时间正确。将 ISO 时间字符串中的数值与时间单位占位符一一对应后，就可用正则表达式把时间数据替换进模板里了~ 20. 如何对传递的 URL 发出 POST 请求？const request = ( path, method = \"GET\", body = null, header = { \"Content-Type\": \"application/json\" }, option = { responseType: \"json\" } ) => new Promise((resolve, reject) => { const client = new XMLHttpRequest(); (client.onload = () => resolve(client.response)), (client.onerror = reject); client.open(method, path); for (const name in header) client.setRequestHeader(name, header[name]); Object.assign(client, option); client.send(body && typeof body === \"object\" ? JSON.stringify(body) : body); }); console.log( await request(\"https://jsonplaceholder.typicode.com/posts\", \"POST\", { userId: 1, id: 1337, title: \"Foo\", body: \"bar bar bar\" }) ); 【知识点】 XMLHttpRequest() Object.assign() 有些小伙伴看了上面的代码可能要说： 要用基于 Promise 的 AJAX，干嘛不用 fetch()？XHR 还要自己封装…… 其实标准化后的 XHR 功能很强大，比 fetch() 还灵活，水歌开发的网络库 KoAJAX 就基于它实现~ 总结自 HTML 5、DOM 4、ECMAScript 6 以来，各种新 API、语法糖层出不穷，再加上 API polyfill 补丁、Babel 语法转译器，Web 前端工程师早已不需担心浏览器兼容性，大胆使用原生 API、语法写出简洁的代码，专注于业务和上层架构。 以上经验来自水歌开源的 WebCell 组件引擎升级最新 API 和语法之路的一些心得。同时，WebCell 也全面拥抱了 TypeScript，并已形成官方生态库矩阵，支撑了多个生产项目，欢迎大家一起研讨、开发！ 相关推荐《如何用开源软件办一场技术大会？》","link":"/article/engineering/ecmascript-dom-skills/"},{"title":"GitHub 在线 IDE 初体验","text":"之前就有听说 GitHub 将推出在线 IDE，一搜索发现很多结果。 现在 GitHub 的在线 IDE 发布一段时间了，官方命名为：GitHub Codespaces（点击可以申请），今天我们就来体验一下。 基础体验在这里，我就拿本人博客的仓库来简单跑一下 GitHub Codespaces。 创建 IDE在 Clone 的按钮选择“Open With Codespaces” 创建流程 进入之后会列出已有的 IDE 列表，没有的话点击下面的新建就是了。 创建流程 进入 IDE开始进入是在初始化，然后就是同步一些配置。 我们会发现在 VS Code 的配置和插件扩展都会被同步过来（当然，前提是你本地的 VSC 和自己的 GitHub 绑定起来，并且同步配置）。 同时，IDE 可以自动识别 package.json 安装依赖，进来就自动安装好了。 点击查看日志还可以查看初始化的日志。 基本使用预装基础环境简单的几行代码，我们可以发现 IDE 已经预装了 node、docker、npm、git、python 等等基础开发环境。 预安装基础环境 启动项目首先全局安装 Hexo，再启动项目 yarn d。 yarn add global hexo 因为 GitHub 的环境在外面，因此安装速度还是很快的，纵享丝滑。 外部端口的打开如果我们的页面需要启动本地端口，IDE 也会提示出来有外部端口。 端口打开 我们也可以在“Remote Explorer”看到全部的端口映射情况 Remote Explorer 我们点击在浏览器打开，然后就可以看到页面了。 当我们修改之后，在侧边栏直接提交就是了，简单快捷。也不用任何的设置。 进阶玩法我们的项目不仅仅是前端项目，也有可能是后端 Server，这里我就用一个后端 Server 来简单演示一下。 安装依赖跑起来 全局安装 nodemon 进入 server 目录安装依赖 很明显这里报错了，原因是我们的 Server 需要连接 PostgreSQL，而我们没有安装。 不恰当的安装方法找到一篇教程，照着代码跑起来。 sudo apt-get update sudo apt-get install postgresql postgresql-client # 创建一个数据库超级用户 postgres sudo -i -u postgres 最后，我们会卡在这里，因为我们不知道 Codespace 的密码，因此安装失败。 Docker 出马我们可以观察到 Codespace 已经为我们安装了 Docker，而且在现在相当流行容器化部署，上面的那种安装方式也不够优雅。 因此运行命令，安装 PostgreSQL docker run -p 5432:5432 -v /home/docker/postgresql/data:/var/lib/postgresql/data -e POSTGRES_PASSWORD=123456 -e TZ=PRC -d --name=some-postgres postgres // -p 端口映射 // -v 将数据存到宿主服务器 // -e POSTGRES_PASSWORD 密码（默认用户名 postgres） // -e TZ=PRC 时区：中国 // -d 后台运行 // --name 容器名称 运行之后，找不到镜像会自动去拉取镜像 查看下状态 现在重启 server，发现已经可以连接上了。 端口我们可以在“Forwarded Ports”增加端口转发 简单演示一下 Get 请求，并且是即时的，修改之后可以通过域名来访问。 顺便说一句，如果我们在代码中写好 URL 地址，就可以直接用鼠标在命令行打开对应端口，网址也会被进行替换。 注意但是也需要注意，如果我们用 Postman 去请求就无法正常请求结果。 如果我们访问 /graphql，请求就会提示“Server cannot be reached”和一些跨域错误。 总结优点俗话说，工欲善其事必先利其器。 编程更重要的是一种思想，而编码更重要的是去表达思想。 如果我们将配置环境，机器选择的的步骤省下来，让自己更加专注于思想表达，专注于编码的话，这样会让我们事半功倍。而现在 GitHub IDE 就可以看成 VSC 的网页版。如果你将 VSC 的配置同步到 GitHub 账户的话，你打开在线 IDE 的时候就会直接同步配置，你会很快上手。 除此之外，GitHub 的里面预装各种环境，让你不再苦恼于环境安装，而且所处的网络环境也很棒，各种库、配置下载起来也是很快，我想这对我们的帮助也是很大的。比如再也不用纠结 node-sass 下载不下等尴尬场景。 遇到紧急的事情，一个浏览器就可以让你专注开发，这难道不香吗？ 不足虽然 GitHub 在线 IDE 有很多优点，但是还是有一些不足，肯定不能和 VSC 真机比拟。比如一些接口 /graphql，就没有本地真机开发的那么爽。除此之外，真机的 VSC 就有很多辅助扩展。比如 PicGo 来实现图片上传到 GitHub 做图床，在浏览器 IDE 里面经过测试是跑不通的。 我测试的时候限制了同时启用两个 IDE，不然会提示你让你处理。 因为每个人所处的网络环境不同，不用高级姿势访问有可能会出现链接断开的情况，这倒是有点硬伤。🤣 结语之前听过“阿里 云电脑”，加上现在 5G 的逐渐普及，说不定未来大家需要的只是一个显示器，可以完成学习、工作和娱乐，配置全部都在远端。听起来天方夜谭，说不定在未来就会实现。 一个新兴事物的出来，肯定引起人们的好奇和质疑。仔细想想 GitHub 被微软收购之后，先后推出了个人无限私有仓库，免费使用 GitHub Actions，再有 GitHub Codespaces。而微软也先后推出 TS、VSC 等市场举足轻重的开源项目。我所看到是开源界的发展和繁荣，也希望未来越来越好。 撒花！","link":"/article/engineering/github-ide-first-time/"},{"title":"GraphQL + Koa + React 项目实践","text":"项目背景源于 2019 年 11 月 16 日 FCC 成都社区主办的 Web 全栈大会上尹吉峰老师的 GraphQL 的分享，让我产生了浓厚的兴趣。GraphQL 是一个用于 API 的查询语言，是使用基于类型系统来执行查询的服务端运行时（类型系统由你的数据定义）。一个 GraphQL 服务是通过定义类型和类型上的字段来创建的，然后给每个类型上的每个字段提供解析函数。 参考学习资料： https://graphql.cn/learn/ https://typescript.bootcss.com/basic-types.html https://www.apollographql.com/docs/react/ 基于以上的一番学习，做了个实践的小项目，就代码做以下分析。 （附上项目地址：react-graphql-project） 项目目录项目分为前端和后端两部分（目录 client 和 server），如图所示： 使用技术栈： client：React hooks + TypeScript + Apollo + GraphQL + Ant Design server: Koa 2 + GraphQL + koa-graphql + Mongoose 项目搭建及源码实现数据库部分使用的 MongoDB 数据库，这里对于该数据库的安装等不做赘述。 默认已经具备 MongoDB 的环境。接下来，启动数据库。 到 MongoDB 安装路径下，如 C:\\Program Files\\MongoDB\\Server\\4.2\\bin 打开终端，执行命令： mongod --dbpath=./data 创建项目总目录：react-graphql-project，并进入目录。 后端部分创建项目，并初始化mkdir server && cd server npm init -y 安装项目依赖yarn add koa koa-grphql koa2-cors koa-mount koa-logger graphql 配置启动命令package.json { \"scripts\": { \"start\": \"nodemon index.js\" } } 业务开发入口文件index.js 这里我们启动一个 Koa 服务，进行日志监听，支持跨域操作，并将 GraphQL 服务挂到 Koa 服务上。通过 koa-graphql 提供 HTTP 服务，传入 schema，并启动 graphiql。graphiql 在测试和开发过程中都非常有用，但生产环境下应禁用它。 const Koa = require(\"koa\"); const mount = require(\"koa-mount\"); const graphqlHTTP = require(\"koa-graphql\"); const cors = require(\"koa2-cors\"); const logger = require(\"koa-logger\"); const myGraphQLSchema = require(\"./schema\"); const app = new Koa(); // 日志 app.use(logger()); // 跨域支持 app.use( cors({ origin: \"*\", allowMethods: [\"GET\", \"POST\", \"DELETE\", \"PUT\", \"OPTIONS\"] }) ); app.use( mount( \"/graphql\", graphqlHTTP({ schema: myGraphQLSchema, graphiql: true // 开启graphiql可视化操作playground }) ) ); app.listen(4000, () => { console.log(\"server started on 4000\"); }); 数据库连接创建 model 文件 model.js 这里我们建立数据链接，定义 schema，并生成对应的 model 导出。schema 是 mongoose 里会用到的一种数据模式，可以理解为表结构的定义。每个 schema 会映射到 MongoDB 中的一个 collection，它并不具备操作数据库的能力。model 是由 schema 生成的模型，可以对数据库进行操作。 const mongoose = require(\"mongoose\"); const Schema = mongoose.Schema; // 创建数据库连接 const conn = mongoose.createConnection(\"mongodb://localhost/graphql\", { useNewUrlParser: true, useUnifiedTopology: true }); conn.on(\"open\", () => console.log(\"数据库连接成功！\")); conn.on(\"error\", error => console.log(error)); // 用于定义表结构 const CategorySchema = new Schema({ name: String }); // 增删改查 const CategoryModel = conn.model(\"Category\", CategorySchema); const ProductSchema = new Schema({ name: String, category: { type: Schema.Types.ObjectId, // 外键 ref: \"Category\" } }); const ProductModel = conn.model(\"Product\", ProductSchema); module.exports = { CategoryModel, ProductModel }; schema.js 定义查询的 schema 对象。在 GraphGL 中有许多内置的 Schema Types 可供我们用来定义字段名类型。这里我们通过定义查询对象类型，通过 model 就可以对数据库进行增、删、改、查等相应操作了。 const graphql = require('graphql'); const { CategoryModel, ProductModel } = require('./model'); const { GraphQLObjectType, GraphQLString, GraphQLSchema, GraphQLList, GraphQLNonNull } = graphql // 分类类型定义 const Category = new GraphQLObjectType({ name: 'Category', fields: () => ( { id: { type: GraphQLString }, name: { type: GraphQLString }, products: { type: new GraphQLList(Product), async resolve(parent){ let result = await ProductModel.find({ category: parent.id }) return result } } } ) }) // 商品类型定义 const Product = new GraphQLObjectType({ name: 'Product', fields: () => ( // ... ) }) // 根查询对象 const RootQuery = new GraphQLObjectType({ name: 'RootQuery', fields: { getCategory: { // 通过id获取分类 type: Category, args: { id: { type: new GraphQLNonNull(GraphQLString) } }, async resolve(parent, args){ let result = await CategoryModel.findById(args.id) return result } }, // ... 其他查询定义 } }) // 根变更对象 const RootMutation = new GraphQLObjectType({ name: 'RootMutation', fields: { addCategory: { //根据name添加分类 type: Category, args: { name: { type: new GraphQLNonNull(GraphQLString) } }, async resolve(parent, args){ let result = await CategoryModel.create(args) return result } }, // ... 其他变更定义 } }) module.exports = new GraphQLSchema({ query: RootQuery, mutation: RootMutation }) 启动项目yarn start 访问 http://localhost:4000/graphql 看到数据库操作 playground 界面。可进行一系列数据库 CRUD 操作。 前端部分创建项目npx create-react-app client --template typescript 配置 webpackyarn add react-app-rewired customize-cra 更改 package.json 文件的 scripts 启动命令 { \"scripts\": { \"start\": \"react-app-rewired start\", \"build\": \"react-app-rewired build\", \"test\": \"react-app-rewired test\" } } 然后在根目录下新建 config-overrides.js 文件，以添加 webpack 的相关配置。 安装前端 UI 组件库 antd，并配置按需加载、路径别名支持等。 yarn add antd babel-plugin-import config-overrides.js const { override, fixBabelImports, addWebpackAlias } = require(\"customize-cra\"); const path = require(\"path\"); module.exports = override( fixBabelImports(\"import\", { libraryName: \"antd\", libraryDirectory: \"es\", style: \"css\" }), addWebpackAlias({ \"@\": path.resolve(__dirname, \"src/\") }) ); 因为 TS 无法识别，还需配置 tconfig.json 文件。 新建 paths.json 文件 { \"compilerOptions\": { \"baseUrl\": \".\", \"paths\": { \"@/*\": [\"src/*\"] } } } 更改 tconfig.json { \"compilerOptions\": { \"target\": \"ES5\", \"lib\": [\"DOM\", \"DOM.Iterable\", \"ESNext\"], \"allowJs\": true, \"jsx\": \"react\" }, \"include\": [\"./src/**/*\"], \"extends\": \"./paths.json\" } 重启项目后生效。 业务开发入口文件index.tsx 首先我们需要创建 Apollo 客户端，传入启动的后端地址作为 uri 的值，将生成的客户端实例通过 context 注入到整个单页应用中。 // ... import ApolloClient from \"apollo-boost\"; import { ApolloProvider } from \"@apollo/react-hooks\"; import App from \"./router\"; // 创建apollo客户端 const client = new ApolloClient({ uri: \"http://localhost:4000/graphql\" }); ReactDOM.render( , document.getElementById(\"root\") ); 路由文件router.js 主要包括商品列表页、商品详情等路由的配置。 import React, { Suspense, lazy, memo } from \"react\"; import { BrowserRouter as Router, Route, Switch } from \"react-router-dom\"; import { Spin } from \"antd\"; const Layouts = lazy(() => import(\"@/components/layouts\")); const ProductList = lazy(() => import(\"@/pages/productlist\")); const ProductDetail = lazy(() => import(\"@/pages/productdetail\")); const RouterComponent = () => { return ( 404 Not Found} /> ); }; 定义类型文件types.ts export interface Category { id?: string; name?: string; products: Array; } export interface Product { id?: string; name?: string; category?: Category; categoryId?: string | []; } 布局组件src/components/layouts import React from \"react\"; import { Layout, Menu } from \"antd\"; import { Link } from \"react-router-dom\"; const { Header, Content, Footer } = Layout; const Layouts = props => ( 商品管理 {props.children} ©2019 - {new Date().getFullYear()} Created by zhangyanling77.{\" \"} ); export default Layouts; GraphQL 查询语句文件api.ts import { gql } from \"apollo-boost\"; // 获取所有的商品 export const GET_PRODUCTS = gql` query { getProducts { id name category { id name products { id name } } } } `; // ... 其他查询语句定义 商品列表组件 ProductList 实现商品列表展示、删除商品、新增商品等功能。 // ... 其他依赖引入 import { useQuery, useMutation } from \"@apollo/react-hooks\"; import { CATEGORIES_PRODUCTS, GET_PRODUCTS, ADD_PRODUCT, DELETE_PRODUCT } from \"@/api\"; // ... const ProductList = () => { // ... 其他状态定义 const { loading, error, data } = useQuery(CATEGORIES_PRODUCTS); const [deleteProduct] = useMutation(DELETE_PRODUCT); // ... 错误处理，加载中处理 const { getCategories, getProducts } = data; const confirm = async (event, record) => { // 删除商品 await deleteProduct({ variables: { id: record?.id }, refetchQueries: [ { query: GET_PRODUCTS } ] }); setCurrent(1); }; const columns = [ // ... ]; // ... return ( setVisible(true)}> 新增 {/* ... */} {visible && ( )} ); }; const AddForm = ({ handleOk, handleCancel, categories }) => { // ... 其他状态定义 let [addProduct] = useMutation(ADD_PRODUCT); const handleSubmit = async () => { await addProduct({ variables: product, refetchQueries: [ { // 添加成功后执行查询全部商品的操作，是个回调 query: GET_PRODUCTS } ] }); setProduct({ name: \"\", categoryId: [] }); // 清空表单 handleOk(); }; return ( {/* ... */} ); }; export default ProductList; 商品详情组件 ProductDetail 根据 ID 查询商品详情及其所属商品分类下的所有商品。 // ... import { useQuery } from \"@apollo/react-hooks\"; import { GET_PRODUCT } from \"@/api\"; import { Product } from \"@/types\"; const ProductDetail = props => { let _id = props.match.params.id; let { loading, error, data } = useQuery(GET_PRODUCT, { variables: { id: _id } }); // ... 错误处理 const { getProduct } = data; const { id, name, category: { id: categoryId, name: categoryName, products } } = getProduct; return ( 商品ID： {id} 商品名称： {name} // ... 商品列表展示 ); }; export default ProductDetail; 结语通过这个项目实践，基本掌握了 GraphQL 的使用。虽然这个项目只包含了简单的 CRUD 功能，但是对后端、数据库、前端都涉及到了，因此对于学习拓展来说也是不错的。后续也继续实现了登录验证、个人中心等功能，这里不做详细介绍，可自行查看项目代码了解。","link":"/article/engineering/graphql-koa-react-project-practice/"},{"title":"JavaScript 效率工具","text":"每当看到发在 FCC 成都社区群里的技术文章，水歌都忍不住去指出它的不足。 今天评注的文章题为《一批提升你工作效率的 JS 工具方法》，文中的 60 个方法与上次评注的“24 个 ES 方法”类似，不够简洁、优雅，与最新 ECMAScript、DOM 标准有些差距，有些“复制粘贴老文章片段”的感觉。 接下来，我就按功能类别来对一些有必要优化的工具方法一一重构。 数据校验完全基于正则表达式的检验规则其实可以不用封装成函数，全放在独立的模块中，导入后直接 /regexp/.test(data) 即可。 电邮地址export const Email = /^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$/; // 原文：/^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((.[a-zA-Z0-9_-]{2,3}){1,2})$/ 「注解」 \\w 即为 [a-zA-Z0-9_] [] 表示一个字符范围，就是一个整体，无需 () 包围 Gmail 等服务商还支持形如 name.filter@gmail.com 这样的用户别名邮箱 (.[a-zA-Z0-9_-]{2,3}){1,2} 只适用于前些年常见的 .cn、.com.cn 一类根域名，近几年新增的 .name、.info、.club、.camp 等域名就失效了，形如 vip.xxmail.com 的多级域名也不适用 手机号码其实以下只适用于中国大陆手机号，其它国家手机号似乎与固定电话号之间没有明显的区分。 export const Mobile = /^1[3-9]\\d{9}$/; // 原文：/^1[0-9]{10}$/ 「注解」 \\d 即为 [0-9] 中国大陆手机号第二位目前没有 1、2 固话号码中国大陆固定电话号码“区号 + 机号”始终为 11 位。 export const Phone = /^((0\\d{2}-)?\\d{8}|(0\\d{3}-)?\\d{7})$/; // 原文：/^([0-9]{3,4}-)?[0-9]{7,8}$/ 网址export const URL = /^\\w+:\\/\\/\\S+$/; // 原文：/^http[s]?:\\/\\/.*/ 「注解」 URL 协议不仅包括 http、https，还有 ftp（文件传输）、file（本机文件系统）、ed2k（电驴 2000）等各种各样的网络协议 URL 主机名、路径可以是 Unicode 中各种可见字符，但遇到空白符就结束 日期格式判断是否为合法的日期格式除了用正则之外，还可利用 Date 构造函数内部的算法： export const isDate = raw => !isNaN(+new Date(raw)); 对于无法解析为日期的数据，date.toString() 会返回“Invalid Date”，date.getTime() 对应的返回值则是 NaN。而算数运算符会调用对象的 valueOf() 方法，date.valueOf() 的返回值又与 date.getTime() 相同。 汉字“汉字”在计算机领域的学名叫中日韩统一表意文字（俗称 CJK），在 2017 年 6 月发布的 Unicode 10 标准中，它有了代码级明确的指代： export const HanZi = /\\p{Unified_Ideograph}/u; 【详情参考】 最佳实践 学习：正则分析器 RegExr、Regex101 前端：HTML 5 表单校验 API 后端：基于装饰器的数据校验 数据转换阿拉伯数字转中文ECMA-402 标准（ECMAScript 国际化 API）把各语言之间的数据格式转换算法都封装好了，我们引入 polyfill 就可以直接用： export const toChineseNumber = raw => new Intl.NumberFormat(\"zh-Hans-u-nu-hanidec\").format(raw); 数据类型判断一个值的类型，用比较构造函数名或类名的方式兼容性比较差，因为线上环境通常是压缩后的代码，自定义的函数名、类名不再是原名，应用开发者一般也不会实现 Symbol.toStringTag getter 类成员，导致 Object.prototype.toString.call() 只会返回默认值 [object Object]。 JavaScript综上，我们应该利用 JavaScript 原型继承，来统一判断“值的类型归属”： export const isType = (value, constructor) => Object(value) instanceof constructor; 「注解」 Object 构造函数会返回所有基本值的包装对象 TypeScript下面，我再给出一个 TypeScript 的实现，让类型推断更加准确： export function isType( value: T, constructor: { new (...data: any[]): T } ): value is T { return Object(value) instanceof constructor; } import { isType } from \"./utility\"; let test; if (isType(test, Number)) console.log(test!.toFixed(2)); 【在编辑器中体验 TS 类型提示】 浏览器检测以下使用 globalThis 是为了兼容浏览器主线程、Web Worker、Node.js、Deno 等不同 JavaScript 运行时环境。 品牌export const isBrowserVendor = ( name, UA = globalThis.navigator?.userAgent || \"\" ) => UA.toLowerCase().includes(name); 爬虫export const isRobot = (UA = globalThis.navigator?.userAgent || \"\") => /bot|spider|crawler/i.test(UA); 去除 HTML 标签正则表达式以下使用了 non-greedy（非贪婪模式）来提升性能，并规避正文中可能出现的示例代码没完全转译尖括号，导致删除错误。 export const removeHtmlTag = raw => raw.replace(//g, \"\"); DOM API下面再提供一种借助 DOM 引擎的实现： const box = document.createElement(\"template\"); export function removeHtmlTag(raw) { box.innerHTML = raw; return box.content.textContent; } URL 参数追加URL()、URLSearchParams() 在浏览器主线程、Web Worker、Node.js 10+、Deno 均全局可用。 export function appendQuery(path, data, base = globalThis.location.href) { const URI = new URL(path, base); const { searchParams } = URI; for (const key in data) searchParams.append(key, data[key]); return URI + \"\"; } W3C、ECMA 标准还有一些可以用新标准（部分为提案）直接实现的特性，集中罗列如下： .trim()、.trimStart()、.trimEnd()（原文第 53 条） .includes()（原文第 42 条） Array.from()（原文第 48 条） 数组去重（原文第 44 条） 动态 import（原文第 27 条） element.classList（原文第 29 ~ 31 条） saveAs()（原文第 28 条） text-transform（原文第 54 条） 开源库 水歌把日常开发中积累的各种工具方法，用 TypeScript 写成一个 Web 开源工具库 —— https://web-cell.dev/web-utility/ ，欢迎大家使用、改进！~","link":"/article/engineering/javascript-efficiency-utility/"},{"title":"webpack 打包文件分析（上）","text":"前言webpack 是一个用于静态资源打包的工具。它分析你的项目结构，会递归的构建依赖关系，找到其中脚本、图片、样式等将其转换和打包输出为浏览器能识别的资源。 本篇文章仅对 webpack 打包输出的文件进行简要的分析。 项目准备项目地址 看一下几个关键文件： 依赖文件 src/foo.js module.exports = \"foo\"; 入口文件 src/index.js const foo = require(\"./foo.js\"); console.log(foo); webpack 配置文件 webpack.config.js const path = require(\"path\"); module.exports = { mode: \"development\", // 标识不同的环境，development 开发 | production 生产 devtool: \"none\", // 不生成 source map 文件 entry: \"./src/index.js\", // 文件入口 output: { path: path.resolve(__dirname, \"dist\"), // 输出目录 filename: \"bundle.js\" // 输出文件名称 } }; bundle 分析首先放上打包输出文件 dist/bundle.js (function (modules) { // 模块缓存对象 var installedModules = {}; function __webpack_require__(moduleId) { if (installedModules[moduleId]) { return installedModules[moduleId].exports; } // 创建一个新的模块对象 var module = (installedModules[moduleId] = { i: moduleId, // 模块id，即模块所在的路径 l: false, // 该模块是否已经加载过了 exports: {} // 导出对象 }); modules[moduleId].call( module.exports, module, module.exports, __webpack_require__ ); // 标识模块已经加载过了 module.l = true; return module.exports; } // 该属性用于公开modules对象 (__webpack_modules__) __webpack_require__.m = modules; // 该属性用于公开模块缓存对象 __webpack_require__.c = installedModules; // 该属性用于定义兼容各种模块规范输出的getter函数，d即Object.defineProperty __webpack_require__.d = function (exports, name, getter) { if (!__webpack_require__.o(exports, name)) { Object.defineProperty(exports, name, { enumerable: true, get: getter }); } }; // 该属性用于在导出对象exports上定义 __esModule = true，表示该模块是一个 ES 6 模块 __webpack_require__.r = function (exports) { // 定义这种模块的Symbol.toStringTag为 [object Module] if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) { Object.defineProperty(exports, Symbol.toStringTag, { value: \"Module\" }); } Object.defineProperty(exports, \"__esModule\", { value: true }); }; // 创建一个命名空间对象 // mode & 1: 传入的value为模块id，使用__webpack_require__加载该模块 // mode & 2: 将传入的value的所有的属性都合并到ns对象上 // mode & 4: 当ns对象已经存在时，直接返回value。表示该模块已经被包装过了 // mode & 8|1: 行为类似于require __webpack_require__.t = function (value, mode) { if (mode & 1) value = __webpack_require__(value); if (mode & 8) return value; if (mode & 4 && typeof value === \"object\" && value && value.__esModule) return value; // 创建一个命名空间对象 var ns = Object.create(null); // 将ns对象标识为es模块 __webpack_require__.r(ns); // 给ns对象定义default属性，值为传入的value Object.defineProperty(ns, \"default\", { enumerable: true, value: value }); if (mode & 2 && typeof value != \"string\") for (var key in value) __webpack_require__.d( ns, key, function (key) { return value[key]; }.bind(null, key) ); return ns; }; // 获取模块的默认导出对象，这里区分 CommonJS 和 ES module 两种方式 __webpack_require__.n = function (module) { var getter = module && module.__esModule ? function getDefault() { return module[\"default\"]; } : function getModuleExports() { return module; }; __webpack_require__.d(getter, \"a\", getter); return getter; }; // 该属性用于判断对象自身属性中是否具有指定的属性，o即Object.prototype.hasOwnProperty __webpack_require__.o = function (object, property) { return Object.prototype.hasOwnProperty.call(object, property); }; // 该属性用于存放公共访问路径，默认为'' (__webpack_public_path__) __webpack_require__.p = \"\"; // 加载入口模块并返回模块的导出对象 return __webpack_require__((__webpack_require__.s = \"./src/index.js\")); })({ \"./src/foo.js\": function (module, exports) { module.exports = \"foo\"; }, \"./src/index.js\": function (module, exports, __webpack_require__) { const foo = __webpack_require__(\"./src/foo.js\"); console.log(foo); } }); 根据上面的源码可以看出，最终打包出的是一个自执行函数。 首先，这个自执行函数它接收一个参数 modules，modules为一个对象，其中 key 为打包的模块文件的路径，对应的 value 为一个函数，其内部为模块文件定义的内容。 然后，我们再来看一看自执行函数的函数体部分。函数体返回 __webpack_require__(__webpack_require__.s = \"./src/index.js\") 这段代码，此处为加载入口模块并返回模块的导出对象。 可以发现，webpack 自己实现了一套加载机制，即 __webpack_require__，可以在浏览器中使用。该方法接收一个 moduleId，返回当前模块的导出对象。 webpack 文件加载 (__webpack_require__)var installedModules = {}; function __webpack_require__(moduleId) { if (installedModules[moduleId]) { return installedModules[moduleId].exports; } var module = (installedModules[moduleId] = { i: moduleId, l: false, exports: {} }); modules[moduleId].call( module.exports, module, module.exports, __webpack_require__ ); module.l = true; return module.exports; } // ... 首先，当前作用域顶端声明了 installedModules 这个对象，它用于缓存加载过的模块。在 __webpack_require__ 方法内部，会对于传入的 moduleId 在缓存对象中查找对应的模块是否存在，如果已经存在，返回该模块对象的导出对象；否则，创建一个新的模块对象，记录当前模块 id、标识模块是否加载过、以及定义导出对象，同时将它放到缓存对象中。 接下来就是重要的一步，执行模块的函数内容，传入 module、module.exports 及 __webpack_require__ 作为参数。 modules[moduleId].call( module.exports, module, module.exports, __webpack_require__ ); 也就是去执行自执行函数传入的 modules 对象中当前 moduleId 对应的函数。接着将该模块标识为已经加载的状态，最后返回当前模块的导出对象。此时便完成了模块的加载任务。 接着，再来看看传入的 modules 对象部分。 ({ \"./src/foo.js\": function (module, exports) { module.exports = \"foo\"; }, \"./src/index.js\": function (module, exports, __webpack_require__) { const foo = __webpack_require__(\"./src/foo.js\"); console.log(foo); } }); 观察函数体内容，可以看到对于依赖模块 foo.js 而言，函数体内即为 foo.js 文件中的定义内容。而对于入口模块 index.js，则需要执行 __webpack_require__ 方法将依赖的文件加载进来使用。 那么，到此为止，我们已经明白了 webpack 加载模块的基本原理。但细心的你一定发现了，我们的文件导入导出遵循的是 CommonJS 规范，而 webpack 是基于 Node.js 实现的，所以在文件加载部分并没有特别的处理。因此，这里我们来看看不同模块规范相互加载时，webpack 是如何处理的。 harmony（和谐，即对于不同模块规范加载的一个兼容处理） CommonJS 加载 CommonJS 这种方式即我们上面示例的加载方式，就不做赘述了。 CommonJS 加载 ES modulesrc/foo.js export default \"foo\"; src/index.js const foo = require(\"./foo.js\"); console.log(foo); dist/bundle.js ({ \"./src/foo.js\": function (module, __webpack_exports__, __webpack_require__) { __webpack_require__.r(__webpack_exports__); __webpack_exports__[\"default\"] = \"foo\"; }, \"./src/index.js\": function (module, exports, __webpack_require__) { const foo = __webpack_require__(\"./src/foo.js\"); console.log(foo); } }); 由打包后的源码可以发现，当 foo.js 使用 ES module 方式导出，与之前的相比，多了 __webpack_require__.r(__webpack_exports__)这段代码，__webpack_exports__ 很好理解，即模块的导出对象。那么，__webpack_require__.r 方法是干嘛的呢？ // ... __webpack_require__.r = function (exports) { if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) { Object.defineProperty(exports, Symbol.toStringTag, { value: \"Module\" }); } Object.defineProperty(exports, \"__esModule\", { value: true }); }; // ... 根据其实现可知，该方法将传入的对象标识上 __esModule=true，即表明该模块为 ES 6 模块。同时定义该对象的 Symbol.toStringTag 为 Module，即当使用 Object.prototype.toString.call 时将返回 [object Module]。 最后，将模块的内容挂在 __webpack_exports__ 的 default 属性上。 ES module 加载 ES modulesrc/foo.js export default \"foo\"; src/index.js import foo from \"./foo.js\"; console.log(foo); dist/bundle.js ({ \"./src/foo.js\": function (module, __webpack_exports__, __webpack_require__) { __webpack_require__.r(__webpack_exports__); __webpack_exports__[\"default\"] = \"foo\"; }, \"./src/index.js\": function ( module, __webpack_exports__, __webpack_require__ ) { __webpack_require__.r(__webpack_exports__); var _foo_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( \"./src/foo.js\" ); console.log(_foo_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]); } }); 当入口文件 index.js 和依赖文件 foo.js 都遵循 ES module 的方式时，可以发现在 index.js 中，对于获取导出对象的方式也有所不同。_foo_js__WEBPACK_IMPORTED_MODULE_0__ 用来接收导入的文件，并通过 default 属性获取到文件的默认导出内容。 那么，是如何实现这种方式的呢？ // ... __webpack_require__.d = function (exports, name, getter) { if (!__webpack_require__.o(exports, name)) { Object.defineProperty(exports, name, { enumerable: true, get: getter }); } }; // ... __webpack_require__.n = function (module) { var getter = module && module.__esModule ? function getDefault() { return module[\"default\"]; } : function getModuleExports() { return module; }; __webpack_require__.d(getter, \"a\", getter); return getter; }; __webpack_require__.o = function (object, property) { return Object.prototype.hasOwnProperty.call(object, property); }; // ... 分析这几个方法可以发现，__webpack_require__.o 其实就是 Object.prototype.hasOwnProperty 的一个重写，用于判断对象自身属性中是否具有指定的属性。而 __webpack_require__.d 即 Object.defineProperty，这里用于定义兼容各种模块规范输出的 getter 函数。__webpack_require__.n 则是用于获取模块的默认导出对象，兼容 CommonJS 和 ES module 两种方式。 ES module 加载 CommonJSsrc/foo.js module.exports = \"foo\"; src/index.js import foo from \"./foo.js\"; console.log(foo); dist/bundle.js ({ \"./src/foo.js\": function (module, exports) { module.exports = \"foo\"; }, \"./src/index.js\": function ( module, __webpack_exports__, __webpack_require__ ) { __webpack_require__.r(__webpack_exports__); var _foo_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( \"./src/foo.js\" ); var _foo_js__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n( _foo_js__WEBPACK_IMPORTED_MODULE_0__ ); console.log(_foo_js__WEBPACK_IMPORTED_MODULE_0___default.a); } }); 当入口文件 index.js 以 ES module 的方式加载遵循 CommonJS 规范的 foo.js 时，通过 __webpack_require__ 加载传入的模块，将得到的模块 _foo_js__WEBPACK_IMPORTED_MODULE_0__ 再传入 __webpack_require__.n 方法获取到该模块的默认导出对象。因为 foo.js 中的内容是通过 export 导出，而非 export default 导出。因此 foo 被挂在了 default 的一个 a 属性上。 结语webpack 对于不同模块规范的相互加载的处理，我们已经有了基本的了解。但此时我们的文件加载都是同步的，那么文件的异步加载又是怎么样的呢？ 请听下回分解。","link":"/article/engineering/webpack-bundle-analyse-0/"},{"title":"webpack 打包文件分析（下）","text":"回顾上一篇webpack 打包文件分析（上）我们讲到 webpack 打包源码中文件加载的部分，通过分析了解了在 webpack 中不同模块规范相互加载的处理。而至此，只包括了文件的同步加载分析，对于文件的异步加载又是如何处理的呢？ 我们使用 webpack 将项目打包为一个 bundle.js 文件，通过 script 标签插入到页面中引用。但如果这个 bundle.js 体积特别大，就会导致我们加载时间过长，阻塞页面的渲染。 其次，这个打包出来的 bundle.js 中其实部分的代码资源是当前加载页面用不到的，这样也导致了浪费。于是，资源加载的优化就成了必须要考虑的问题，而异步加载（或者说动态加载）就是解决这个问题的方案之一。 异步加载在 webpack 中提供了符合 ECMAScript 的 import() 语法，允许我们动态的加载模块。（在 webpack 版本较低时，我们使用的代码动态加载方案是 require.ensure 方法，后面已经被 import() 取代）。 那么接下来，就继续探究一下异步加载的实现。 关键文件 src/foo.js export default \"foo\"; src/index.js // /* webpackChunkName: \"foo\"*/: 魔法字符串，设置打包后的chunk名 import(/* webpackChunkName: \"foo\" */ \"./foo\").then(foo => { console.log(foo); }); webpack.config.js // ... output: { path: path.resolve(__dirname, 'dist'), // 输出目录 filename: '[name].bundle.js', // 输出文件名称 }, // ... bundle 分析打包后输出两个文件： foo.bundle.js 因为是异步加载的方式，单独打包为一个文件。由于打包后的源码内容过长，这里省略部分已经分析过的代码块。 index.bundle.js (function (modules) { function webpackJsonpCallback(data) { // ... } /** * 该对象用于存储已经加载和正在加载中的chunks * undefined：表示chunk未加载 * null：表示chunk预加载 / 预获取 * Promise：表示chunk正在加载中 * 0: 表示chunk已经加载了 */ var installedChunks = { index: 0 // 默认入口模块已经加载完毕 }; function __webpack_require__(moduleId) { // ... } // 设置加载chunk的脚本路径 此处的 __webpack_require__.p 为 publicPath，默认为\"\" function jsonpScriptSrc(chunkId) { return ( __webpack_require__.p + \"\" + ({ foo: \"foo\" }[chunkId] || chunkId) + \".bundle.js\" ); } // ... // 作用：懒加载代码块，原理使用 JSONP __webpack_require__.e = function requireEnsure(chunkId) { var promises = []; // ... return Promise.all(promises); }; // ... // 异步加载时触发的错误函数 __webpack_require__.oe = function (err) { console.error(err); throw err; }; // 存储的是传入的chunk var jsonpArray = (window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []); // 存储旧的 jsonpArray.push 方法 var oldJsonpFunction = jsonpArray.push.bind(jsonpArray); // 用 webpackJsonpCallback 覆盖 jsonpArray.push 方法 jsonpArray.push = webpackJsonpCallback; jsonpArray = jsonpArray.slice(); for (var i = 0; i { console.log(foo); }); } }); foo.bundle.js // [[这里存chunk的名称], {这个对象是存放chunk路径及chunk内容定义的键值对}] (window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([ [\"foo\"], { \"./src/foo.js\": function ( module, __webpack_exports__, __webpack_require__ ) { \"use strict\"; // 将模块标识为 ES Module __webpack_require__.r(__webpack_exports__); // 将函数内容定义挂在 default 上 __webpack_exports__[\"default\"] = \"foo\"; } } ]); 可以看出，对于同步加载的部分（index.js），依然是使用 __webpack_require__ 来进行加载的，这里不做赘述。 观察 index.js 中对于 foo.js 的加载可以发现，使用到了 __webpack_require__.e 方法，该方法接收 chunkName，返回一个 promise，再传入 chunk 的路径，通过 __webpack_require__ 加载 chunk 的内容，最后输出。 那么关键点就是 __webpack_require__.e 这个方法了。 __webpack_require__.e = function requireEnsure(chunkId) { var promises = []; // 获取加载的chunk内容 var installedChunkData = installedChunks[chunkId]; if (installedChunkData !== 0) { // 0 表示已经加载过了 // Promise 意味着 chunk 正在加载 if (installedChunkData) { promises.push(installedChunkData[2]); } else { // 在chunk缓存中设置 Promise var promise = new Promise(function (resolve, reject) { installedChunkData = installedChunks[chunkId] = [resolve, reject]; }); // 此时 installedChunkData = [resolve, reject, promise] promises.push((installedChunkData[2] = promise)); // 开始加载chunk，jsonp方式 var script = document.createElement(\"script\"); var onScriptComplete; script.charset = \"utf-8\"; // 设置字符集 script.timeout = 120; // 和CSP相关 if (__webpack_require__.nc) { script.setAttribute(\"nonce\", __webpack_require__.nc); } // 设置脚本的加载路径 script.src = jsonpScriptSrc(chunkId); // 脚本加载完成、超时、出错的事件处理函数 var error = new Error(); onScriptComplete = function (event) { // 避免IE内存泄漏 script.onerror = script.onload = null; clearTimeout(timeout); var chunk = installedChunks[chunkId]; if (chunk !== 0) { if (chunk) { var errorType = event && (event.type === \"load\" ? \"missing\" : event.type); var realSrc = event && event.target && event.target.src; error.message = \"Loading chunk \" + chunkId + \" failed.\\n(\" + errorType + \": \" + realSrc + \")\"; error.name = \"ChunkLoadError\"; error.type = errorType; error.request = realSrc; chunk[1](error); } installedChunks[chunkId] = undefined; } }; var timeout = setTimeout(function () { onScriptComplete({ type: \"timeout\", target: script }); }, 120000); script.onerror = script.onload = onScriptComplete; document.head.appendChild(script); } } return Promise.all(promises); }; 分析这个方法，它的核心作用就是异步加载的实现。 获取传入的 chunkName 在 installedChunks 对象中对应的加载状态，如果状态为非加载完成，则构造一个 promise，将它的 resolve、reject 作为该 chunk 的正在加载状态，并存入到 promises 中。 创建 script 标签，将 chunk 的路径作为脚本的加载路径，然后插入到页面的 中，让浏览器去下载这个 chunk。 最后返回 promises 的执行结果，让所有的 promise 都变为完成态，即完成所有 chunk 的加载。 接着再来看 foo.bundle.js，整个代码体的目的是在向 window.webpackJsonp 中 push 一个数组，这个数组的结构为 [[\"chunk的名字\"], { \"chunk的路径\": function(){ chunk的内容定义 }}] 。 回到 index.bundle.js 中我们可以找到关于 window.webpackJsonp 的相关定义及使用。 var jsonpArray = (window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []); // 存储旧的 jsonpArray.push 方法 var oldJsonpFunction = jsonpArray.push.bind(jsonpArray); // 用 webpackJsonpCallback 覆盖 jsonpArray.push 方法 jsonpArray.push = webpackJsonpCallback; jsonpArray = jsonpArray.slice(); // 依次调用 webpackJsonpCallback for (var i = 0; i","link":"/article/engineering/webpack-bundle-analyse-1/"},{"title":"【2019 成都 Web 全栈大会】参会指南","text":"本届大会秉持程序员自主办会的宗旨，努力从各方面用编程解决问题。 FCC 成都社区坚信 —— 主办方自身紧跟技术潮流，才能让参会者为之信服！ 【时间】2019 年 11 月 16 ~ 17 日 09:00 ~ 18:00 【地点】成都市高新区天府五街 菁蓉国际广场 7 号楼主会场 【议程】https://web-conf.dev/#2019/ 【报名】http://fcc-chengdu.mikecrm.com/7pG2aOh 大会 App本届大会筹办期间，水歌把整个大会官网用自研的 WebCell v2 重写之外，还把它升级为一个 PWA（渐进式 Web 应用），可直接安装在 Android、Windows、iOS 的桌面上，并支持离线缓存，随时随地查看大会议程！ 下面以 Google Chrome 举个栗子，Firefox、Edge、UC 浏览器、小米手机浏览器、Safari 等均有不同形式、程度的支持： 访问大会官网，自动提示安装 点击提示后，确认安装 稍后即可在桌面看到图标 （Chrome 在国产 Android 上有时较慢，请耐心等待，或刷新重试） App 启动界面 邀请函 从本届大会主页导航栏进入邀请函页面 用买票人手机号登录 （刚买票的数据更新有延迟，请稍候再试） 登录成功自动显示邀请函 长按保存、分享图片 会场导航 大会 App 内嵌高德导航","link":"/article/propaganda/web-conf-2019-guide/"},{"title":"【2019 成都 Web 全栈大会】大咖特辑","text":"今年成都 Web 全栈大会前两波宣传发出去后，有小姐姐私聊我说：XX 讲师小哥哥好帅，好想…… 当面深入交流…… 编程技术！ 那今天我就先带大家预习一下部分讲师的小档案，方便粉丝们现场勾搭有备无患，哈哈~ 对了，记得先买票再上车哦~ 【时间】2019 年 11 月 16 ~ 17 日 09:00 ~ 18:00 【地点】成都市高新区天府五街 菁蓉国际广场 7 号楼主会场 【议程】https://web-conf.dev/#2019/ 【报名】http://fcc-chengdu.mikecrm.com/7pG2aOh 贺师俊 —— 写了 20 年前端的男人一听贺老要来，FCC 成都社区的一位小姐姐激动不已，自告奋勇要当贺老的书童，即兴赋诗一首 —— 今有大佬来蓉分享，穿过大山越过小巷。前排买票一睹风采，堂前一席胜读十书。 贺老从 1998 年 IE 4 时代开始写网页代码，至今身为 TC39、W3C 两个标准委员会的委员，可谓中国 Web 前端界少有的“两院院士”。 自 2008 年 Chrome 发布、2009 年 Node.js 问世，再到 2015 年 ECMAScript 6 出炉，Web 前端标准、生态的发展驶入了高速路，技术标准制定的过程中也有了贺老这样中国程序员的身影。若你浏览一下各项标准提案的 GitHub issue，可以看到很多贺老针砭时弊的话语，可谓一言不合就给你扔一个 SyntaxError！ 语法错误 陈成 —— 阿里 P8，超级奶爸 陈成，网名 sorrycc，花名云谦，阿里巴巴 P8 高级技术专家，毕业于浙江大学，已是两个男孩的爸爸。 2008 年 sorrycc 每个月拿着 4000 块钱在一家小公司打杂，希望老板加薪 500 元，老板都不肯，一气之下加入了阿里，一待就待到现在。前 5 年在淘宝 UED 工作，负责淘宝首页、宝贝详情、购物车和下单等很多重要的前端业务开发，后转岗到支付宝，目前在玉伯带领的蚂蚁金服体验技术部，为现代前端开发输出了源源不断的设计和技术。 截止目前已开源了众多颠覆性的项目，包括不限于： Dva —— 基于 Redux 和 Redux Saga 的数据流解决方案（14K） Umi —— 可插拔的企业级 React 应用框架（6.2K） RoadHog —— 开箱即用的 React 应用开发工具（2.5K） Ant Design —— 中小企业搭建后台管理系统的 React 组件库（53K） 本次有幸请到 sorrycc 大佬来成都参加由 FCC 和 阿里云联合举办的 2019 成都 Web 全栈大会，他将带来 《蚂蚁前端研发最佳实践》主题演讲，主要给大家分享一下蚂蚁前端在语言、CSS、目录结构、路由、数据流、Mock、构建工具、组件开发、测试、性能优化微前端等方面选择的最佳实践，以及最佳实践的迭代、遇到的问题、挑战和他的思考。 慕阳 —— 平凡的铲屎官 慕阳老师，六年开发经验，曾任职美团、人人网，现任华为云高级前端。听到这样的大佬名号，萌新的我真是瑟瑟发抖。直到我看到他发给我的这样一张图片： 没错就是这只自带“眼罩”大懒猫，我才真实的感觉到他也是一个热爱生活的人。他并不是大家想象中的两耳不闻窗外事，一心钻研搞技术的宅男；他也是爱刷抖音、爱跑步，没事撸撸猫、看看电影，外加陪陪女朋友的人。 可能有的同学了解过 Web Components，但实际使用比较多的都是类似于 Vue 或 React 形式的组件。所以大家非常好奇老师将会在这次大会中给我们带来哪些关于 Web Components 的黑科技。 我们已经了解到，老师将以华为云内部复杂的前端业务为背景，结合在实际项目中使用 Web Components 的一些经验，为我们带来一期干货满满的 Web Components 实践分享。希望同学们带好小本本，好好写笔记，一定会有很多收获哦！ 谢扬 —— 互联网之子 谢扬，本届年纪最小的讲师，96 年小鲜肉。他在大二时开发了 Gospel，提供了软件开发的全新解决方案。曾任好东西传送门的 CTO，目前在中国推广万维网之父的 SoLiD 项目，并基于此进行商业化试水。 他活跃于 GitHub，目前自己的创业项目 Authing 已经慢慢浮出水面，受到大家认可。年纪虽小，但是在初中的时候就开始编程，具有很强的编程能力和项目推动能力，十足的领导范儿。 于航 —— 女装真大佬，编码无 bug 本次大会的讲师于航（Jason Yu），除了在多个技术大会上布道之外，平时生活中也是一个极富情调的人，我们都亲切地称呼他为“航妹”。为什么呢？因为他不仅是个极客，还是传说中的“女装大佬”。访问航妹的 Github 个人主页，你就能看到他（她）的女装头像。更有甚者，航妹曾在参与某个开源项目时，被国外开发者误认为是个厉害的妹子。 航妹兴趣广泛。你时常能看到他发一些弹奏钢琴的短视频；也曾在公司组织团队成员练习街舞，参与演出；他甚至还是两只猫主子的铲屎官，一橘一花（其实主要是白色）。 橘猫叫皮卡丘，性子活泼，常常会在航妹准备 coding 之时或趴或蹲在电脑前，一副求关爱的样子。 花猫叫淘淘，性子文静，你如果看不到淘淘，那么不妨去看看航妹的床底。 看到这里，是不是觉得航妹妥妥的小说主角模板啊，有技术，有猫，还多才多艺。 航妹在今年早些时候出版了国内第一本系统介绍 WebAssembly 技术的书《深入浅出 WebAssembly》。WebAssembly 是近年诞生的一门新技术，目前在国内还很少看到相关的应用和实践，这次他来分享 WebAssembly 相关的内容，想了解同学不容错过。 如果你想了解更多关于航妹的事情，可以看看我们之前对他做的一次访谈，FCC DevTalk 002 丨于航：happy coding, happy life，也欢迎大家支持航妹的书《深入浅出 WebAssembly》。","link":"/article/propaganda/web-conf-2019-mentors/"},{"title":"2019 成都 Web 全栈大会","text":"2019 成都 Web 全栈大会 2017-11-19 —— 成都首届 Web 前端大会 2018-01-21 —— Code for City 黑客马拉松 2018-03-31 —— 成都首届 React 技术大会 2018-11-10 —— 成都第二届 Web 前端大会 2019-11-16 —— 成都首届 Web 全栈大会 成都技术氛围不如北上深杭 技术大会都在沿海城市 FCC 成都社区 https://fcc-cd.dev 成都缺乏技术氛围， 我们就自己来营造氛围！ 技术分享会 结对编程/翻译工作坊 黑客马拉松 代码直播 半月度小型技术活动 不定期中型技术活动 年度大型技术会议 家（坝）门（子）口（上）的技术社区 FCC 中文社区https://chinese.freecodecamp.org/ freeCodeCamp 最早的非英语版本 由近百位志愿者在 GitHub 协作翻译 自 2016 年成立， 已在中国各大一二线城市、部分三四线城市落地 中文社区创始人 Miya， 也于 2019 年加入全球全职团队 freeCodeCamp https://freecodecamp.org 从 零基础 到 合格软件工程师 注册用户：全球 300+ 万 全球网站 Alexa 排名：超越同类商业平台 Udacity GitHub 源代码：全球星标第一 Medium 专栏：全球最大 YouTube 频道：编程类最火 线下开发者社区：遍布 160 多个国家、2000 多个城市 全球 7 个全职员工靠着社群捐款， 与千千万万业余贡献者一起， 完成了这个壮举！ 成为计算机教育领域的维基百科 参会者 QQ 群","link":"/article/propaganda/web-conf-2019-prologue/"},{"title":"【2019 成都 Web 全栈大会】工作坊特辑","text":"【时间】2019 年 11 月 16 ~ 17 日 09:00 ~ 18:00 【地点】成都市高新区天府五街 菁蓉国际广场 7 号楼主会场 【议程】https://web-conf.dev/#2019/ 【报名】http://fcc-chengdu.mikecrm.com/7pG2aOh 《AALab 算法艺术实验室》 领域 难度 时间 Unity3D 进阶 2019 年 11 月 16 日 14:00 ~ 17:00 即影即有 —— 异形投影与着色器语言。使用 Unity3D 的着色器可视化编程对于造型进行光影重塑，精准投影附着于实体之上。 叶师父 AALab 算法艺术实验室 - 算法工程师 《AWS 工作坊》 领域 难度 时间 DevOps 入门 2019 年 11 月 17 日 10:20 ~ 11:20 通过 Serverless 工作坊，我们将为您介绍如何使用 AWS Lambda、Amazon API Gateway、Amazon DynamoDB、Amazon S3 等服务来构建 Serverless 应用。您将动手开发并部署一个 Serverless 的 Web 应用，并尝试监控、版本管理和灰度发布等内容。 孙华 亚马逊 AWS - 高级解决方案架构师 《极限编程 —— 测试驱动开发（TDD）工作坊》 领域 难度 时间 敏捷开发 入门 2019 年 11 月 17 日 14:00 ~ 17:00 在各种敏捷方法中，极限编程最为重视软件开发技术工程实践。极限编程是唯一将开发技术实践提到核心地位、并围绕开发技术实践构建起完整软件交付流程的敏捷方法论。 缺少可重构性的软件，不可能快速响应变化。 没有高覆盖率、快速运行的单元测试，重构就不可能落地。 测试驱动开发是获得高质量单元测试集的唯一有效方法。 建立在充分覆盖且运行快速的自动化测试基础上的持续集成是迭代式开发的必要条件。 通过工作坊你将获得： 掌握测试驱动开发的基本节奏 任务分解，用测试用例描述沟通需求 编写失败的测试，驱动产品代码 精准框定需求范围，持续实践重构 受用终身的测试驱动开发方法论 打好程序员基本功、改善工作方式，提高十倍工作效率。 吕靖 中国极限编程社群 - Web 前端工程师","link":"/article/propaganda/web-conf-2019-workshop/"},{"title":"【公益】高考志愿填报助手","text":"2020 年高考是一场非常不容易的高考，毕业生和社会各界都历经艰辛，希望我们的拼搏都能有更加美好的明天。 说起填志愿，回想起我高考时正值汶川大地震。那时我们获取可靠、有效、全面的志愿参考信息，基本只能通过学校发的一本大部头参考书，里面汇集了全国招生的院校、专业和往年录取数据。但这样一本像过去每个城市的电话黄页一样的书，反复查阅它的“低效”痛苦就不用多说了。 进入大学 IT 技术社团之后，就一直想用自己学到的编程技术，来为学弟学妹解决我当年那般的痛苦。但彼时，我国政府部门信息公开政策的保守和技术的落后，让我们很难获得好用的数据，商业平台又有巨大的封闭壁垒，遂作罢…… 直到前一阵子，FCC 一位城市社区组织者在群里分享了黄希彤老师的填教授公益项目，看到他把多年收集的公开数据用统计学方法进一步处理，免费为广大考生做参考，内心十分激动！于是想尽自己现在的专长所能，帮黄老师优化一下前端界面，让广大的考生和家长用起来更方便。 同时黄老师也欣然接受了我一直以来的开源直播方式，于是便有了 FCC 中文社区 B 站直播间长期栏目《水歌酱的开源日常》的首期特别节目《编程帮我填志愿》，也欢迎大家关注 FCC B 站账号以接收日常节目的开播提醒~ 使用入门基本操作 选择考生所在省份、分科后，再填入高考成绩，点击查询按钮即可查询到根据往年录取情况有可能考上的学校和专业 可以下拉选择不同的上线概率后重新查询，来筛选相对保险（高概率、保底）的专业和相对有挑战（低概率）的专业 对于公布位次的省份，可以选择按照位次来查询筛选专业 筛选后页面出现过滤按钮，可以输入感兴趣的学校和专业关键字在结果中进行进一步的筛选 每年招生情况都会发生变化，因此考生在查询后可点击学校、专业名称的链接，进一步了解相关专业当年的招生信息 安装为 App 现代浏览器首次访问自动提示安装 确认安装到桌面 已安装到桌面 App 在系统中独立运行 技术知识为了满足黄老师提出的“除 CSS 样式外，简单业务不依赖任何库”要求，水歌本次对填教授 Web 前端代码的重构采用了最新版 BootStrap、DOM API、JavaScript 标准，刚学完 freeCodeCamp HTML、CSS、JS 基础课程的菜鸟也能快速上手~ 以下是这些易学、易用的标准、通用技术的入门文档： HTML 标签、属性 tabindex 全局属性 hidden 全局属性 iframe 标签的 name 属性 template 标签 CSS :empty 伪类选择符 DOM API CSS 选择器 API document.forms ParentNode 接口 ChildNode 接口 Element.prototype.classList HTMLFormElement.prototype.elements BOM API fetch() URL() ECMAScript API、语法 Array.prototype.map() Array.from() ECMAScript 6 模板字符串 with 语句的利弊 async 函数 第三方开源库、云服务 BootStrap 4.5 API Polyfill 自动补丁服务 CodeSandbox 在线 Web 前端项目沙盒 Parcel 零配置打包器 参考文档以上知识点在 FCC 成都社区之前的技术博文有介绍： 《ECMAScript + DOM 骚操作》 《JavaScript 效率工具》 《如何用开源软件办一场技术大会？》","link":"/article/propaganda/college-applier/"},{"title":"Chrome 性能调试工具","text":"2019 年 06 月 30 日 FCC 分享复盘 分享的示例 上周在 FCC 分享了一次浏览器的渲染性能调优，在分享的过程中大家问到一些问题，并且在分享之后，我自己也发现了一点问题，所以想写一篇文章来总结和复盘。 问：z-index 和合成层有关系吗？答：z-index 跟合成层没有关系，跟渲染层有关系。 参考：层叠上下文 层叠上下文是 HTML 元素的三维概念，这些 HTML 元素在一条假想的相对于面向（电脑屏幕的）视窗或者网页的用户的 z 轴上延伸，HTML 元素依据其自身属性按照优先级顺序占用层叠上下文的空间 渲染层保证页面元素以正确的顺序合成，这样才能正确的展示元素的重叠和半透明等等。满足形成层叠上下文条件的 LayoutObject 就会为其创建新的渲染层。 文档中的层叠上下文由满足以下任意一个条件的元素形成： 根元素 z-index 值不为 auto 的绝对/相对定位 一个 z-index 值不为 auto 的 flex 项目 (flex item)，即：父元素 display: flex|inline-flex opacity 属性值小于 1 的元素（参考 the specification for opacity） transform 属性值不为 none 的元素 mix-blend-mode 属性值不为 normal 的元素 filter 值不为 none 的元素， perspective 值不为 none 的元素， isolation 属性被设置为 isolate 的元素， position: fixed 在 will-change 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值（参考这篇文章） -webkit-overflow-scrolling 属性被设置 touch 的元素 某些特殊的渲染层会被认为是合成层。合成层有单独的 GraphicsLayer。 渲染层提升为合成层的情况： 3D transform 3D 或者 硬件加速的 2D Canvas 元素 will-change 问：什么工具可以查看 CSS 的属性改变触发渲染的方法？答：可以查看：https://csstriggers.com/，这个网站注明了在不同的浏览器内核下，每种 CSS 属性在默认和改变时会触发哪一种渲染操作，后面会有详细解释。 问：这次分享的是针对的什么渲染引擎答：Blink 这里说一点点浏览器的历史吧，最开始 Chrome 是用的苹果公司的 WebKit，后来谷歌和苹果产生了分歧，谷歌从 WebKit 中复制了一个 Blink 项目，所以我们分析渲染性能是针对的 Blink。 对浏览器渲染引擎感兴趣的可以看： https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/ WebKit 技术内幕 虽然 Blink 是 WebKit 的一个分支，但是有很多细节不同。首先，谷歌把 WebKit 的代码梳理得可读性很高，比如 RenderObject 变成了 LayoutObject，RenderLayer 变成了 PaintLayer。所以这里我需要修正一下分享时的渲染流程图，现在 Blink 内核的渲染流程图是下面这个。 当然除了代码可读性高了，渲染的细节也有改变。 分享的时候有人问到为什么我用了 transform 但是在 Layer tab 没有看到合成层。下来我查证了一下，先看一下下面这张 CSS trigger 的图 最上边的 B、G、W、E 分别代表的是：Blink(Chrome)、Gecko(火狐)、WebKit(Safari)、EdgeHTML（Edge 的内核，不过微软已经宣布 Edge 浏览器将切换至 Chromium 内核，也就是 Blink）。 左侧显示的 CSS 属性。 左边的 BGWE 是设置属性（从默认值修改，相当于一开始没设置 CSS）。右边的 BGWE 是修改属性（对现有的属性值进行修改）。 下面每个小方块的颜色就是对应的渲染流程中触发的方法。 从 transform 会触发的方法可以看到，在 Blink 下只触发了 Composite，而在 WebKit 下触发了 Layout、Paint、Composite。从上面列举的会触发合成层产生情况，可以看出 transform 只有在 3D 的情况下才会形成合成层，而在 2D 的情况下是没有合成层的。 上面这个是我分享的优化成了 transform 的例子。如果我把每个小方块都改成 3D 渲染，layer 显示应该是这样的 所以这里需要修正我所讲的“transform 都会形成合成层”，正确的解释应该是： 在所有引擎下 transform 2D 并不会形成合成层，只有 3D 才会形成合成层 在 Blink 引擎下，本身 transform 2D 不会触发 layout 和 paint，而在 WebKit 引擎下仍然会触发 layout 和 paint。 所以 Chrome 提升动画性能仍然会触发 layout 和 paint 的动画操作改为 transform。但是如果是 3d 情况下，形成合成层的元素太多，会很消耗内存，所以需要做一个平衡。","link":"/article/summary/chrome-performance-summary/"},{"title":"FCC 之翻译工作坊","text":"【编者按】一位参加本期工作坊的女生写的活动总结，感谢她和大家的积极参与！ 一、开始之旅当然是再次参加 FCC 成都的活动啦，先上图 二、划重点 FCC 是 freeCodeCamp 不是只讲前端的工作坊呀（对不起原谅我之前没有认真看。其实还有其他学习资料，各种都有呢 还有这个 Quincy Larson 名字很熟悉呀。这不就是隔不了多久就会给我邮箱里发学习资料的人吗？（每次看到邮箱的感觉就是：哇，又有新技术阔以学习了哇 听了 FCC 中文社区创始人、FCC 国际社区唯一中国全职员工 Miya 小姐姐的讲解才知道，原来经常催我学习的人就是创始人呀。 （附上 FCC 介绍的链接） 对于活动的态度。Miya 小姐姐讲的大意是：不用想今天来参加活动的人数是多少，只要做好活动，做你认为有意义的事情。可能这事不大，但可能会改变某些人的一生。 关于翻译的看法：图中有 Miya 小姐姐传授的独门秘籍哟。 关于分享：分享是表达自己呢 那个小礼物扑克呀，是真的好看，质量也好。瞧瞧那光泽，看看那手感，不一样不一样。重点是随便一张都是大佬，随便一握就是几个知识点。大佬在手，便知有没有。 （不行，我要给它们特写，放图！以下） 等等，我们今天的主要任务是翻译啊 三、结对翻译 拿到牌后，现场实时翻译。 讲解翻译规范 正式开始结对，分小组完成任务。 开始翻译之旅，和组员商量确定翻译哪一篇文章。确定后开始协作，比如她有电脑那她负责实际操作和记录，我就负责口头翻译和抉择。 在翻译过程中，有翻译出的中文意思待讨论的部分，刚开始有些争论。后面一点点细细分析后，确定了最后的表述方式。还有很多感受呢。 有人陪着一起做有趣的事，慢慢一起成长的感觉真棒～ 开心，分小组现场翻译的感觉，有点意思哦 四、寻有志同道合的朋友加入我们战队这里是一个小结：快乐的时光总是过的很快。每一次线下交流都会有收获，今天暂且告一小段啦。 成功都是从一个个小点开始积累起来的，这算是一个小小的开始吧。故不积跬步无以至千里，不积小流无以江海。 有兴趣的小伙伴，阔以加入我们。下次翻译坊，期待你的加入哦～ 欢迎认领翻译、校对！ Let’s go to change the world by a little thing.","link":"/article/summary/fcc-technical-translation-0/"},{"title":"7.14 成都社区翻译工作坊回顾","text":"这次翻译工作坊的内容是 News 文章，之后大家也可以用百科作为内容，这是我们社区最近需要重点推进的。 在中文版 News 上线之后，我们是这样规划它的内容的： 和英文版类似，发布技术/产品/设计相关的文章，分享学习编程的经历和求职的经验，分享教学视频，这些内容可以是原创，也可以是翻译。 翻译这部分，我们计划首先从翻译英文版 News 的优质文章开始。之前我们都在这个论坛协作翻译，听取大家的建议之后，我们决定转到 GitHub 协作。 接着，水歌提议说他很早就想组织翻译工作坊，一方面可以帮助大家提升英语水平和熟悉 GitHub 使用，另一方面也可以引导线下活动参与者们更多参与 freeCodeCamp 线上协作，使大家更了解我们的社区在做什么。所以，7 月 14 日，我们在成都社区组织了第一次翻译工作坊。 活动前 静如 @jingruzhang 帮助在 GitHub 翻译仓库理清楚了协作流程，发布翻译任务（issue），我也在逐步增加任务。 7 月 11 日，水歌 @TechQuery 预订活动场地，定下来活动流程，制作报名表；我编写活动报名文案。 我准备 freeCodeCamp 简介 PPT（我会单独发给每个城市社区），详细内容来源于 freeCodeCamp.org 社区概览。 7 月 12 日，开启报名。 活动中 宣传期只有短短两天，报名总人数似乎是 14 人，当天的参与者共 12 人（包括水歌和我）。 活动时间从下午 2 点到 5 点半。 现场共 5 台电脑，还好是结对翻译，大家可以共用电脑（报名文案里我忘了提醒带电脑，我问水歌要不要短信提醒，他说“工作坊不带电脑，来干嘛”，我们都以为大家会有带电脑的默契，然而事实证明该提醒还是得提醒 😂）。 参与者陆续到场，水歌让大家逐个自我介绍，一半人是第一次参加成都社区的活动吧，之前也没有任何铺垫，所以我感觉这个环节气氛有点小尴尬。参与者中有两位是翻译从业者（其中一位女士大概 50 岁吧），对活动好奇就来看看了；还有三位是正在自学编程想要转行的，其他人都是在职开发者，主要目的是练英语吧。当然，还有共同的目的是从社区中认识新朋友，让自己的周末时光充实一点。 接着，我照着 PPT 给大家介绍了 FCC 和我对翻译这件事情的建议“好奇心、同理心、耐心”。我们已经在 GitHub 仓库列出详细的翻译规范，所以我的建议更多是在鼓励大家 enjoy 吧（其实不只是翻译啦，这“三心”也适用于别的很多事情吧 ^_^）。我的初衷是让氛围轻松随意一点，同时让大家多感受 FCC 团队和社区的真实与活力——就像现场一位女生看到 PPT 中的团队照片之后说“Quincy 的名字好熟啊，原来每周给我发邮件的就是创始人啊”——然后我就讲了不少细节故事，大概讲了半小时吧。 我带了一盒 FCC 程序员扑克牌，用于热场。每位参与者随机抽取一张扑克牌，稍微准备一下之后，挨个分享：介绍扑克牌上的程序员，翻译上面的英文句子，讲述自己对这句话的体悟。这个环节蛮有趣，是一个小小的即兴挑战。 然后我们鼓励大家主动分享在热场环节的体验，我记得似乎只有 1 人主动分享了：“Miya 推荐的腾讯翻译君小程序很好用”。 热场之后，氛围变得轻松了些，水歌给大家介绍 GitHub 翻译协作流程，教大家如何 pull request。 然后就开始结对翻译了，这个过程大概 1 小时吧。大家都很认真地讨论，其中有一组很聪明地使用谷歌翻译之后再修订，加快速度。 在有的组遇到一句话不太会翻译的时候，上面提到的两位翻译从业者和我有帮助他们理清楚句子的意思。我也有给我那组两位女生分析一些句子结构。 活动后 活动结束，我们让大家保存好已翻译的内容，回去完成之后再 pull request。合影，自由聊天，部分参与者晚上聚餐。 参与者们很嗨皮地在社区微信群里分享照片，也有发朋友圈，群里有的小伙伴表示羡慕不已“下次一定要参与”。 我跟水歌说隔天发一个反馈表，让大家分享一下参与体验，然而最终没有发。 活动上大家领取了 5 篇翻译任务，10 天过去了，貌似只完成了 1 篇文章吧。我们在群里提醒大家记得完成，两个人回复“ok”。 今天，成都社区公众号发布其中一位参与者的文章，图文并茂，看得出来她很喜欢这个活动，和，我送她的扑克牌 😂 可以提高的地方 水歌提出翻译工作坊可以定期举办，那么我觉得每一期可以提前多几天发布活动文案。 活动前可以把报名者都邀请到群里，自我介绍什么的，线上初步认识一下，也听听大家对活动的期待。广州社区每次活动前就是这么做的，特别好！ 介绍 FCC 社区这个环节的时间要缩短，10 分钟足够了，留多点时间让参与者们多分享、互动。 活动上如果有英语不错的小伙伴可以给大家提供语言帮助，非常好。如果没有的话，大家多用用翻译工具，也还是能搞定大部分内容的，不过不必强求一定要一次性翻译到位，毕竟 pull request 之后还有人帮助校对嘛。 活动后搜集反馈挺重要的。 可以和参与者保持联系，比如问问他们是什么原因没有 pull request。 我的总结大概就是这些了，水歌 @TechQuery 还有什么要补充的吗？ 水歌的补充 我们翻译仓库维护者在准备待翻译文章时，除了在对应 MarkDown 文件中写清原文链接，最好能把原文粘贴到文件中，这样每个译者的 pull request 的变更差异对比界面就能看到双语对比 会前拉群确实可以让大家有所准备，能提高到场率，以前成都这边只有线上工作坊才提前拉群 后面看一下 GitHub API 对文件编辑时的 fork 支持度如何，看能否把我开发的 Git Pager 编辑器给译者用，降低 pull request 的学习成本 会后反馈表后面我做个统一的打分表单方便每次复制","link":"/article/summary/fcc-translation-workshop-0/"},{"title":"如何用开源软件办一场技术大会？","text":"2019 成都 Web 全栈大会技术工作总结 其实今年大会水歌也有不少要分享的心得，可惜忙于大会筹备，没精力准备一个讲题。不过本届大会倒是全面应用了水歌新钻研的技术，会后就和大家简单分享一下。 官网 Web 前端 大会官网 PWA 组件引擎 —— WebCell WebCell 2018 成都 Web 前端大会筹办时，大会官网就用大会开源市集参展者 WebCell 的第一版开发，WebCell 也成为大会当天最火的展位之一。 一年来，其作者水歌一直保持对让 Web 开发更简单的不懈追求，在贺老对 WebCell “装饰器退回 TypeScript 版本”的建议下，花两天时间用 TypeScript 重写出了 WebCell v2 —— Web Components 标准提供的轻量级运行时隔离环境让组件引擎可以用更少的奇技淫巧，降低复杂度（本届大会上慕阳老师的《DevCloud Web Components 实践》也有深入讲解） TypeScript 给 ECMAScript 带来的类型系统不但能充分激发程序员的肌肉记忆，还让本与 HTML 5 相差不大的 JSX 通过类型推导如虎添翼 状态管理 —— MobX MobX WebCell 自 v1 以来的装饰器写法与 MobX 十分搭调，v2 用了 TypeScript 就更是无缝兼容，而且还带来了更清爽的开发思路： 前端路由可以基于状态管理与普通组件来实现，而不再是“特殊的库” —— 路径即状态，容器即组件 登录框也无需做成单独的页面，而变成一个容器组件，避免复杂需求下页面跳转时状态的混乱 —— 有登录状态就渲染 children，否则渲染登录框（像后端中间件一样，让具体业务页面不用管登录状态） 组件库 —— BootCell BootStrap 说到 UI 组件库，很多人可能觉得 BootStrap “不好看”，但水歌却对它情有独钟 —— 官方文档示例代码中的 HTML 结构语义化、无障碍 (Accessability) 堪称“教科书”，对 SEO（搜索引擎爬虫）、屏幕阅读器（视障人士）极为友好 它首先是个 CSS 库，其 CSS 工具类很丰富，几乎覆盖所有常见定制需求，日常开发基本不需要写自己的 CSS 文件，且能保持一致的设计规范，对小项目团队非常友好 因此，在如此规范的设计之上实现一个特定框架的组件库，边写业务边封装都是很快的。 工具链 —— Parcel Parcel 现在 Web 前端开发的第一道门槛恐怕不是 this、闭包、异步了，当属 webpack —— 我司业务代码都写好了，就差一个 webpack 配置工程师了…… 所以，我们转而用面向资源的打包器 Parcel，它能在保持 Web 开发原生资源引入方式的同时，自动处理资源的路径转换、依赖安装、编译流程，没有特殊需求则无需配置文件，三条命令搞定 —— # 安装 npm install parcel-bundler -D # 开发 parcel source/index.html # 构建 parcel build source/index.html PWA 框架 —— Workbox Workbox 虽然天朝因为墙的原因而难以使用 Web Push，但 PWA 图标添加到桌面、Service Worker（后台网络缓存）这些特性，国内用的主流操作系统、浏览器基本都支持了，该标准的亲爹 Google 还推出了强大而方便的工具包，让 PWA 真正 Quick start： # 安装 npm install workbox-cli -g # 配置 workbox wizard # 构建 workbox generateSW 【参考】https://tech-query.me/development/pwa-quick-start/ 电子邀请函 前端生成截图 前端截图 —— SVG foreignObject在 Web 前端页面中截图，最负盛名的库莫过于 html2canvas，但它需要把当前网页的 DOM 树克隆进一个 ，会意外地触发 Web Components 的重绘，遂放弃。 除此之外，在浏览器更新较快的今天，我们终于可以放心地使用 SVG 带来的福利 —— 。它能将 HTML 包在 SVG DOM 中渲染，而 SVG 又是可以被 引用的图片，截图只需用 画一下再输出，就变成 PNG、JPG 这些常用格式了~ Hello, SVG! 【封装】https://github.com/bubkoo/html-to-image 前端请求库 —— KoAJAX国内前端同学最常用的 HTTP 请求库应该是 axios 了吧？虽然它的 Interceptor（拦截器）API 是 .use()，但和 Node.js 的 Express、Koa 等框架的中间件模式完全不同，相比 jQuery .ajaxPrefilter()、dataFilter() 并没什么实质改进；上传、下载进度比 jQuery.Deferred() 还简陋，只是两个专门的回调选项。所以，它还是要对特定的需求记忆特定的 API，不够简洁。 幸运的是，水歌在研究如何用 ES 2018 异步迭代器实现一个类 Koa 中间件引擎的过程中，做出了一个更有实际价值的上层应用 —— KoAJAX。它的整个执行过程基于 Koa 式的中间件，而且它自己就是一个中间件调用栈。除了 RESTful API 常用的 .get()、.post()、.put()、.delete() 等快捷方法外，开发者就只需记住 .use() 和 next()，其它都是 ES 标准语法和 TS 类型推导： import { HTTPClient } from \"koajax\"; var token = \"\"; export const client = new HTTPClient().use( async ({ request: { method, path, headers }, response }, next) => { if (token) headers.Authorization = \"token \" + token; await next(); if (method === \"POST\" && path.startsWith(\"/session\")) token = response.headers.Token; } ); 不仅如此，其上传下载进度还是个 Observable 对象（RxJS 粉丝们喜闻乐见），而且是个下文会详述的升级版： import { request } from \"koajax\"; const { upload, download, response } = request({ method: \"POST\", path: \"/files\", body: new Blob([\"Hello, Observable!\"]), responseType: \"json\" }); for await (const { loaded } of upload) console.log(`Upload ${file.name} : ${(loaded / file.size) * 100}%`); const { body } = await response; console.log(`Upload ${file.name} : ${body.url}`); BaaS 后端云服务 —— NodeTS-LeanCloud【声明】笔者是自来水，绝无商业广告之意。 在云服务大行其道的今日，开发应用貌似必谈云原生，本届大会也有阿里云的《从 Infrastructure as Code 到 Open Application Model —— 填补开发到运维的鸿沟》和 AWS 的《无服务器计算架构》两个主题来着力科普云计算架构。但无论是前者的 IaaS（基础设施即服务）还是后者的 FaaS（函数即服务），对于初创全栈应用而言，其粒度不是太大就是太小，水歌还是青睐粒度适中的 BaaS（后端即服务）。 而 BaaS 中的翘楚，国外莫过于 Google Cloud 收购的 Firebase，国内则是 LeanCloud 深耕数年（它的创始人还是 YouTube 的创始人陈士骏，说起来都是谷歌家的，哈哈）。 BaaS 不但能像 IaaS、PaaS 一样基于 Docker 运行完整的各种语言写的后端项目，而且还封装了数据库、对象存储、消息推送、实时通讯等各种常用基础设施，数据库也默认实现了基于角色权限的用户系统和应用内搜索，这一切只需调用 SDK 的 API，而无需关心安装与运维。其数据库的 API 和后端常用的 ORM（对象关系管理）库差不多，SQL、分库分表、负载均衡这些都不用操心了，抄起键盘就撸业务代码才是王道！ 同时，借助其 SDK 的云函数 API，也能在同一个项目里实现 FaaS 的能力，对热衷代码本身的人来说更加灵活。 【模板】https://github.com/TechQuery/NodeTS-LeanCloud Email as a Hook —— IterableObserver经常制作表单的天朝程序员想必知道，国内各大表单服务商无论界面是否花哨、功能是否强大，都没有方便的后端 API，与 Google Forms 等国外平台相去甚远。数据的后续处理只能手工导出 Excel 再转 CSV 导入其它数据库，无论实时性、便捷性，简直不可同日而语。 如何在参会者购票成功后，大会官网可查到其报名信息？这让我们头疼了好久…… 幸好我们的合作方 MikeCRM 有个邮件通知功能，可以用它模拟一个 Web Hook 接口。于是，便找了个基于 IMAP 协议的邮件通知监听库 mail-notifier。 虽然它能实现功能，但随之而来的问题是，邮件客户端重启时集中发来的新邮件事件会并发大量 API 请求，BaaS 服务商会直接断掉后续请求…… 如何将事件流串行起来？大家自然会想到 RxJS，但它有点重。再仔细想一下，事件通常是异步的，异步的串行不就是异步迭代吗？那我们能否将 Observable 封装成 ES 2018 的 Async Iteration 呢？ 其实最初版的 Async Iteration 提案中异步生成器的返回值就是一个 Observable，后来才拆成单独的提案孵化，可以推测二者是能相互转化的。 于是，水歌尝试用已成为标准的 Async Generator 来实现一个 Observable，便有了 Iterable Observer，新邮件的串行处理也可以从离散的 Callback 改写成线性的 Iteration： const newMail = Observable.fromEvent(client, \"mail\"); (async () => { for await (const { html } of newMail) { await new MikeCRM(html).saveUser(); } })();","link":"/article/summary/web-conf-2019-open-source/"},{"title":"【总结】文言编程工作坊","text":"序夫混沌初开，阴阳分晓。盖两仪化四象，四象生八卦，八卦生无穷，此天地万物之生也。至冯祖降世，悟有无之道，尽天机之正，锻金为骨，化爻为髓，作精妙之仪，御之以电，上可演九章算术，下可推少广方田， 乃开后世之先河。 然则阴阳之道，众人难之，皆欲代之以文，谓之语言。不意甲子之期未至，百家争鸣已然，程式语言之多，繁若《天官》之星宿，奇胜《山经》之走兽。然以文言编程者，似所未有。有奇人 LingDong，宿好文章，且通程式，乃做斯言，行文言编程之事。且承开源之大义，此当吾辈之所以勉励也。 吾辈小子数人，尝创可思摩斯之奥义。结其于文言程式之中，乃凭文法之妙，于方寸之间，创宇宙之万物。行此聚会，以文、程二物会友。固为一乐，并望君能于乐中有所获矣。 始己亥年末，应程式之营所召，有朋数人，结伴于成都以南，紫荆谷中，引水流觞，以身践之，探寻文言程式之妙。较之以前汉字程式者，解其流行之道，悟其语法之意。期间，遇以文言程式难尽示万物之色，则畅言其未来之法。或曰以天干地支所代之，或曰以古法以充其文。诸如此类云云，语尽而意远，相得而益彰。 然则言谈终觉少，尚需躬行之。于是拟定四题，名曰： 问天地之好在 嘶嘶嗡嗡 求斐氏列 可思摩斯 题既定矣，闲话少言，乃以程式会之。 问天地之好在习程之人尽知，欲习一言，必先呼之。是乎，吾等乃以天地好在问之，书之于天地轮回之间，此乃入门之式也，不提。 嘶嘶嗡嗡一言既书，继而解题。题面曰：若有一术，设其能计之以数，然则其计数也，若逢倍三，则以诗之上阙以和之，若逢倍五，则以诗之下阙以和之，若倍三倍五，则和以全诗，问此如何？是谓「嘶嘶嗡嗡」之术也。 欲解此题者，需用以程式条件控之。题面虽简，然则精简之法层出不穷。不期在座者，皆乃浸淫程式之道十数载，仿若庖丁解牛，不出片刻便相继夺彩。 求斐氏列世间万物，看似无甚相关者，冥冥之间却有所连矣。若海螺，若花朵，若星河，凡视之谐者，皆有同理，后世称之为「黄金分割术」。宇宙万物其被设计乎？ 有先祖斐氏，探宇宙规律与其中，乃发现有一数列，自一始之，加相邻两项，以为后续之项。无限周转，则该列可复现此「黄金分割」之美于奥秘之间。 大巧若拙，大道至简。吾辈感先人之明，乃以文言程式求此「斐氏列」，现其于天地轮回之间，感其至妙也。 可思摩斯有朋者秋，乃创「可思摩斯」之书。施其义，则可于「万物初始」之时创精灵若干，且在「天地轮回」之中控其于股掌之间。若精妙习之，实乃天地万物之创始者也。 秋尝观东洋之景，见其精怪，悚之。今与众人以「可思摩斯」之书重现之，以壮众人胆色也。并依此例，阐述于文言程式中创世天地之法。众人习之，皆有所得。 结不觉间，时辰已过，众人乐之，并留念于紫荆谷中，互叮再约之期，乃去。","link":"/article/summary/wenyan-workshop-summary/"},{"title":"算术逻辑单元 ALU | 书香讲 CS 之五","text":"ALU 介绍上次我们讲到了计算机如何表示和存储数字以及文字，但计算机真正的目标是进行计算、有意义地处理数字，比如把两个数字相加等等。这些事是由计算机的一个叫“算术逻辑单元（ALU）”的部件来处理的。ALU 是计算机的大脑，也是现代计算机的基石，基本上计算机所有的操作运算都会用到它。 ALU 有 2 单元，1 个算术单元，1 个逻辑单元，所以接下来分两块来分别介绍它们。 英特尔 74181，第一个封装在单个芯片内的完整 ALU 算术单元算数单元负责计算机里所有的数字操作，比如加减法等等。要完成“将两个数相加”这个操作，需要制造出新的部件“加法器”,我们会用之前抽象出的“逻辑门” —— 与门、或门、非门、异或门 —— 来进行更高层次地抽象，组装成我们想要的部件！ 半加器最简单的加法电路，就是拿两个比特（0 或 1）加在一起。它会有 2 个输入，以及 1 个输出：两个输入数字的和。 我们的输入和输出都只有 1 个比特，所以会有以下几种情形出现： 0 + 0 = 0 0 + 1 = 1 1 + 0 = 0 1 + 1 = 2 = 10（二进制） 注意，在二进制里没有 2 这个数字，计算出来的结果需要进位，表示为 10。发现了什么？这 4 个加法结果的末尾和之前讲的“异或门”的输入输出结果一模一样！于是我们放上一个异或门： 但我们 1 + 1 这个运算的结果是 10，有一个“进位”上的数字被置为了 1，所以我们可以用之前的“与门”加入一条“进位”输出电路，来保存这个进位： 我们就制造出了一个“半加器”，把它进行抽象，加入我们的工具箱： 全加器半加器只能计算 1 位二进制的运算，如果超过了 1 位，我们就需要“全加器”。想一想我们之前的二进制计算，半加器相加后可能产生进位，那之后每一位的计算可能就会有 2 个对应位的数字加上“进位”的数字。因此，我们的全加器就会有 3 个输入，以及 2 个输出，它的可能性也多了许多： 我们可以利用半加器来做制作全加器，首先用一个半加器将两位数字相加，再把“进位”的数字输入另一个半加器，与前一个半加器输出的“和”进行运算，最后再用一个“或门”来监测是否有新的“进位”： 这样就制造出了全加器！同样我们把它抽象，加入工具箱： 8 位二进制加法器接下来，让我们看看怎么制作一个 8 位的加法器。假设我们要把两个名字为数字“A”和数字“B”的 8 位二进制的数相加。 首先，我们需要一个半加器把这连个数字的最右边一位“A0”和“B0”加起来，得到一个“和”输出和一个“进位”输出。 然后下一位的数字“A1”和“B1”除了对应相加，还要加上前一位的“进位”输出，因此我们连上一个全加器，同样得到了“和”与“进位”的输出。 再将上一步的“进位”输出连入下一个全加器就可以计算下一位数字了，以此类推，就可以制造出 8 位二进制的加法器了： 注意，我们最后一位的数字计算是有“进位”的，如果两个相加的数过大，在这里产生了进位，结果超出了 8 位，这就叫做“溢出 (overflow)”。 溢出意味着结果超出了对应位数可以表示的数字，这会导致错误和不可预期的结果。例如以前在 8 位机上玩“吃豆人”的时候，如果你玩到了第 256 关（8 位二进制最多可以表达 0~255），那屏幕上就会出现乱码，游戏就会出错： 为了避免“溢出”，我们可以加更多的全加器来制造 16 位、32 位、甚至 64 位的加法器。代价就是需要更多的逻辑门部件来制造，并且每次进位会花一些更多的时间。 其他操作另外，除了加法，算术单元也可以进行其他的运算，大概有一下这些： 加法（ADD） 减法（SUBTRACT） 增量+1（INCREMENT） 减量-1（DECREMENT） 不同的计算也跟加法器类似，是用不同的逻辑门组合出来的。但是在其中并没有乘法或除法，因为简单的 ALU 中并没有专门的器件来处理这两个运算，而是通过重复多次的加法或减法来完成的，例如： 12 × 5 = 12 + 12 + 12 + 12 + 12 但是现代计算机、智能手机等更好的处理器中，为了速度更快，也加入了乘法和除法的运算单元。它们更复杂一些，但也是通过更多个逻辑门的各种组合来实现的！ 逻辑单元顾名思义，逻辑单元在计算机内负责执行逻辑操作。比如之前说的“与”、“或”、“非”、“异或”。另外，它还能做简单的数值测试，比如利用许多个“或门”，来检测一个 8 位数字是否为“0”： ALU 抽象利用大量逻辑门的组合，我们可以构建出一个 ALU。回到一开始提到的英特尔 74181，它只能处理 4 位输入，并且不能直接进行乘除法的计算。即便如此，要构建出它，也用了 70 个逻辑门： 仅仅 4 位的 ALU 已经如此复杂了，而 8 位的 ALU 更是需要几百个逻辑门，因此工程师们在使用 ALU 的时候，将它抽象成了一个符号： 它接受两个操作数输入(InA，InB)，以及 1 个表示要进行的是哪个运算的操作代码 (Opcode)，然后输出一个结果 (Out)。 另外 ALU 还会有各种标志位 (flag)，来表示计算的状态。例如： 进位标志 (Carry flag) 表示这次计算有没有进位，0 标志 (Zero flag) 表示这次计算的结果是不是为 0，这样就可以方便地判断计算是否溢出，或者两个输入的数是否相等。高级的 ALU 中，会有更多的标志位，可以帮助处理器更快更方便地运算。 之后目前为止，我们了解了电子计算机是如何在没有齿轮的情况下进行计算的了。接下来，我们会利用 ALU 来制造计算的 CPU（中央处理器），越来越接近我们现在的计算机了！下次见~","link":"/article/theory/arithmetic-logic-unit/"},{"title":"计算机中的二进制 | 书香讲 CS 之四","text":"二进制数字之前我们制作出了逻辑门，让计算机可以表示逻辑“真”或“假”。但是只靠这两个状态，我们没法表达更多的信息，这时，我们就需要了解一些数学了。别紧张，这个可能比你初中学的数学还要简单！ 用一个二进制的数可以表示“真”或“假”，我们用数字的方式计为 1 或 0。想要表达更多的信息怎么办呢？让我们想想十进制的数，一个数字可以表示 0 ~ 9，如果想表示 10 以上的数字，我们就在前面加上一位，就能表示出 0 ~ 99 的数字。二进制也是同样，通过在前面添加位数，可以表达更多的信息。 用十进制举例来说，数字 183 代表了什么呢？它表示了 1 个 100、8 个 10 以及 3 个 1 全部加起来： 183 = 1 × 100 + 8 × 10 + 3 × 1 注意我们乘的每个数都比右边的大 10 倍，因为每一位数字可以表示 10 个数字（0 ~ 9），只有超过 9 的才会加一位。这样基于每一位都有 10 个数字的计数方式，就是十进制。 二进制的原理是一样的，只不过它每一位只有 2 个可能的数字（0、1），所以我们要乘的每个数都比右边的大两倍，不再是 100、10、1，而变成了 4、2、1。比如说二进制数 101，就代表了 1 个 4、0 个 2、1 个 1 相加，等于十进制的 5： 101 = 1 × 4 + 0 × 2 + 1 × 1 为了表示更多的信息，我们会有更长的二进制数，比如说 10110111，就代表了十进制的 183： 10110111= 128 × 1 + 0 × 64 + 1 × 32 + 1 × 16 + 0 × 8 + 1 × 4 + 1 × 2 + 1 × 1= 183 二进制计算二进制的加减计算也很简单，我们同样还是从十进制举例。当我们计算 183 + 19 的时候，我们从个位开始，每一位对应相加，如果加出来的结果大于 10，就向下一位进一位： 同样，我们用二进制来计算，结果是一样的： 计算机中的二进制数计算机中，二进制数的每一位叫做 “比特（bit）”。一个 8 个比特的数字最小是 0，最大是 11111111（255），总共能表示 256 个，也就是 2 的 8 次方个不同的数字。 在计算机中，我们处理的二进制位数都是 8 位的倍数，以至于我们给每 8 个比特单独起了个名叫做 “字节（Byte）”。你可能听过 KB 、MB、GB、TB，他们的单位都是字节，前面的字母代表了数量级：KB 代表一千字节，MB 代表一百万字节，GB 代表十亿字节，而 TB 就代表了一万亿个字节，也就是 8 万亿个 0 和 1！ 以前我们玩的“8 位机”，就代表他们的数据都是用 8 个比特来表示的。而现在的计算机一般都是 64 位机。 一个“8 位图像”，就代表它每一个像素点的颜色由 8 个比特来表示，也就是每个点可以有 256 种可能的颜色；而“32 位图像”就表示每个点可能有 2 的 32 次方，也就是 4,294,967,296 这么多种颜色，那可清晰多了！ 8 位图片 64 位图片 负数、非整数并不是所有的数字都是正数，一般计算机会用第 1 位作为标志位来表示正负，1 表示是负数，0 表示是正数。例如一个 32 位的数，第一位表示正负，剩下的 31 位表示数字，能表示的范围就大概是 -2,147,483,648 ~ 2,147,483,648。 表示小数的规则相对复杂些，目前较常用的是 IEEE 754 标准。它将 32 位数设置成了 1 个正负标志位（S）、8 个指数位（E）、23 个有效数字位（M），最后表示的数字（V）计算公式如下： ASCII 码，计算机中的字符表示除了数字以外，计算机还通过给每个字符编上代码的方式，用二进制来表示文字。1963 年发明的 ASCII 码（美国信息交换标准代码）一直通用到现在。ASCII 码由 7 位二进制数表示，可以表达 128 个不同的字符，包括了大写字母、小写字母、数字 0 ~ 9，大部分标点符号及一些换行符、制表符等特殊符号。 比如说：字母“A”就由 65 表示，字母“b”是由 98 表示，标点“!”就用 33 表示等等。 ASCII 码表 UNICODEASCII 码简单易用，它使用不长于一个字节长度的二进制编码来解决了字符的问题。但是，ASCII 码却有个明显的缺陷：它只能供英语使用，其他国家的文字，比如中文有数千个常用字，根本没法用一个字节来编码。 各个国家都研究了自己的多字节编码方案，但因为各个国家的编码方案互不通用，导致在不同系统之间，就会产生乱码问题。例如，以前我们玩台湾或日本开发的计算机游戏，打开是乱码显示，需要使用转码器才能正常玩耍，就是这个原因。 1992 年，Unicode 诞生了，它统一了所有编码的标准，解决了不同国家不同编码标准的问题。常见的 Unicode 是 16 位的，可以表达超过一百万个字符，足够覆盖所有语言的每个字符了 —— 100 多种语言的字母（文字）大概占了 12 万个位置、剩下的还可以表示各种标点符号、数学符号、甚至 Emoji 表情！ 其他编码除了 ASCII 码，Unicode 编码表示字符以外，还有其他常见的例如 MP3、PNG、MP4 等等各种编码格式，可以用来表达声音、图片、视频等信息。我们在计算机中见到的照片、音乐、电影、游戏、网页、甚至操作系统，它们归根到底都是一串很长的“0、1”比特！ 之后了解了计算机基本的表达形式：二进制，以及它的计算以及编码。接下来，我们就会真正走进计算机的“计算”方式，看看在计算机内部是怎么操作这些二进制，来帮助人们完成工作的。下期见~","link":"/article/theory/binary-in-computer/"},{"title":"布尔逻辑与逻辑门 | 书香讲 CS 之三","text":"二进制我们从机械计算机，升级到了机电计算机，再到了电子计算机，逐渐希望用“电”来代替“机械运作”进行计算。减少了机械设备，就能降低计算机的物理磨损，可以使计算更加可靠，也变得更快。 还记得莱布尼茨的步进计算机吗？它用 10 个齿的齿轮来代表十进制数进行计算。然而，当我们试图用电流强弱的程度来表达十进制的时候，却发现受到的干扰太多了（比如计算机电池要没电了，或者电源电压不稳等等）。为了解决这个问题，人们尝试过制造五进制，三进制的电子计算机，却依然不能进行可靠的计算。于是，可以只用电流“开”，“关”两种状态进行表达的二进制计算机被设计了出来。 二进制只有“真”或“假”两个值，也可以表示成“1”或“0”。当电路闭合，电流流过的时候，表示“真”；电路断开，没有电流流过的时候表示“假”，这样的方式很难受到外界的干扰，可以让我们的计算机工作的更加稳定！ 逻辑门电路使用二进制的另外一个原因是，有一整套的数学计算的方法，来专门处理“真”或“假”，那就是布尔代数。它是以 19 世纪的英国数学家 George Boole 的名字来命名的。 Boole 一直致力于用一种类似常规代数的计算方法，来处理亚里士多德哲学中的逻辑问题。对比于代数中的加减乘除，布尔代数也有三个基本计算方式，那就是“与”，“或”，“非”。让我们分别来了解一下，并用晶体管制作出这三种基本门电路： “非”门“非”运算非常简单，它拥有一个输入和一个输出，运算结果就是把原来输入的结果反转： 前面提到，晶体管类似于一个水龙头一样，当接通控制电路的时候，半导体导电，输出就有了电流；断开控制电路的时候，输出就没有电流。 为了制造“非”门，我们需要将晶体管的输入输出极调整一下：我们将晶体管的一极接地，另外一极接通输出电路。这样，当我们接通控制电路的时候，电流就直接流入地面，而不会流过输出电路，只有断开控制电路的时候，电流才流过输出电路。想象成我们把水龙头安在了一个大的排水管上，关闭排水管，家里的水管里才有水；打开排水管，家里的水管就没水了。 “与”门“与”门需要两个输入，只有当着两个输入同时为“真”的时候，输出才为“真”，只要任意一个输入为“假”，则输出就为“假”。 比如：奥巴马是美国总统与奥巴马是黑人，结果为真；奥巴马是美国总统与奥巴马是白人，结果就为假。 制造“与”门电路，我们需要将两个晶体管串联起来。这样，用两个晶体管的控制电路作为输入，就必须两个输入端都接通，输出电路才有电流流过。 “或”门“或”门同样需要两个输入，并且只要任意一个输入为“真”，则输出就为真；只有当两个输入都为“假”的时候，结果为“假”。 同样的例子：奥巴马是美国总统或奥巴马是白人，结果为真；奥巴马是韩国总统或奥巴马是黄种人，结果为假。 制造“或”门电路，我们同样需要两个晶体管，只不过这次我们需要加一些额外的线路将它们并联： 抽象在真实世界中，即使是职业的程序员或工程师也并不总会去关心电流是怎么在计算机里流动的。人们往往会将常用的零件组装成一个粒度更大，使用更方便的工具，而不需要再去关心零件的细节，这样的过程就叫做“抽象”。 同样，我们现在做出了“与”,“或”，“非”三种门电路，人们抽象出了三种符号来分别代替它们： 与门 或门 非门 “异或”门除开这三种基本操作以外，还有个非常有用的布尔运算教做“异或”，异或和或运算非常像，当任意一个输入为“真”的时候，输出为“真”；不同点在于，当两个输入都为“真”，或者两个输入都为“假”的时候，输出为“假”。换句话说，只有当两个输入状态不一样的时候，输出为“真”；两个输入状态一致的时候，输出就为“假”。 利用晶体管来制造“异或”门电路就相当复杂了，还好我们可以用抽象出来的工具：“与”、“或”、“非”门来组装它： 后面会提到，“异或”操作非常有用，所以工程师们将“异或”门抽象成了一个“笑脸”的符号 :)D ，这是新的一层抽象，赶快把它放进工具箱，再也不用关心它是由哪几个门电路或者多少个晶体管组成的了！ 异或门 之后从现在开始，我们终于用电信号来表示我们的数据（真、假）了。并且通过逻辑运算，我们能描述出较为复杂的逻辑，比如：如果小明在周末或情人节买了玫瑰与两张电影票等人看电影，那么小明谈恋爱了为真。 我们用二进制表述出了逻辑，接下来，我们将会看看二进制在计算机里是怎么表示、存储和计算的。","link":"/article/theory/boolean-logic-and-logic-gate/"},{"title":"计算机早期历史 | 书香讲 CS 之一","text":"手动计算设备有记载中，人们最早使用的的计算设备是——算盘。 最早的算盘大约在公元前 2500 年，发明于美索不达米亚。由于当时的社会规模已经远远超出了人们的心算能力（比手指脚趾加一起还多），因此需要帮助计算加减，并且能存储计算状态的手动计算器。 算盘计数：6302715408 随着社会的发展，人们还发明了各种计算工具： 星盘，用于在海上计算维度 计算尺，用于帮助计算乘除法 日晷，用于计算潮汐，天体运动或计时 Computer最早的 Computer 出现于 1613 年，是一种职业，专指负责计算的人。“Computer”们会借助一些工具来帮助计算，但主要还是靠人力。 “computer”们在工作 直到某一天，戈特弗里德·莱布尼茨说：“让优秀的人浪费时间算数简直侮辱尊严，文盲用机器能算得一样准”，于是他发明了步进计算器。步进计算器有一串齿轮，每个齿轮 10 个齿，代表 0-9，每次超过 9 就让前面的进一位，减法时反向运动。经过巧妙的设计，可以方便地进行多次加减法，来完成乘法和除法。 莱布尼茨步进计算器 通过机械化的计算器，大大简化了计算器的操作方式，降低了计算人员的学习成本。但是这种计算器计算较大的数字时，依然很费时间，往往一次计算要耗时几个小时到几天不等。另外因为造价高昂，因此并没有得到足够的重视。 计算表为了快速进行更为复杂的计算（例如指数，对数，三角函数等），人们将计算好的结果提前算好，并制成计算表方便查询。 在军事中，因为经常需要更为快速，精准的机选，计算表的方式得到了广泛的运用。例如在炮兵中，炮手发射的炮弹会因为风力，温度，大气压等等环境因素的变化而影响射程，而很难打中目标。根据使用射程表，通过当前的环境因素和射程，来快速计算出当前应当设置的炮的仰角，大大提高了命中率。 拿破仑军队中的炮兵计算表 但是，如果更换了新的火炮或者炮弹，对应的计算表都需要重新计算，依然会非常耗费人力和时间。 分析机“随着知识的增长和新工具的诞生，人工劳力会越来越少。” Charles Babbage 认为通过机器应该可以自己完成通用的计算过程，并于 1837 年设计出了分析机，可以自动运算一系列运算操作。 Ada Lovelace 为分析机写了假象的程序，并预言：“未来会诞生一门全新的，强大的，专为分析所用的语言“（计算机程序雏形）。 因为设计理念过于超前，分析机的制作成本过高，导致这个设备并没有真正制造出来。但是人们通常认为 Charles Babbage 是通用计算机之父，而 Ada Lovelace 是第一个程序员。 伦敦科学馆的分析机复制品 电动计算器19 世纪末，计算设备往往用于科学或者工程等特定领域。但是随着大量移民导致地人口增长，美国政府在 1890 年的人口普查中却遇到了问题。 美国宪法规定每 10 年进行一次人口普查，统计各项数据，用于分配联邦资金等等。然而在 1890 年需要进行普查的时候，发现根据当时人口数量，统计计算各项数据需要 13 年之久！还没统计计算完就需要进行下一次普查了！ 美国政府找到了 Herman Hollerith，发明了电动机械计算器。这个计算器采用传统步进计算器的方式进行计数，却将其他用于操作的结构用电动设备连接了起来。通过插入打孔的卡片，来控制电路系统，从而代替人力操作来完成统计和计算。 打孔计算器 打孔卡 这种计算器的运行速度大概是手动速度的 10 倍，并在人口普查中为美国政府节省了大约 500 万美金的开支。 这个成绩，使得越来越多的公司意识到打卡计算器的优势。于是，Hollerith 干脆成立了打卡机器公司，并在 1924 年与其他机械制造商合并，改名成为了 IBM（国际商用机器公司）。 之后1900 年代中叶，随着人口爆炸式增长以及贸易的兴起，对数据的计算量大大增加。但是机械计算器在长期运作中造成的磨损，而产生的的计算错误以及成本提高问题越来越严重。人们迫切需求更快更灵活的工具处理大量的数据，这为电子计算机的发展奠定了基础，让咱们下期讨论~","link":"/article/theory/early-computer-history/"},{"title":"电子计算机 - 书香讲 CS 之二","text":"机电计算机的弊端随着人口爆炸型增长，贸易开启、战争需求以及对科学工程更高级的研究，人们对数据计算的要求越来越高。打卡式的机电计算机的出现，代替了人们手工式的计算，极大的提高了计算效率。 世界上最大的机电计算机之一是由 IBM 公司在 1944 年生产的“哈佛马克一号”，这部计算机重达 4500 公斤，由 76 万 5 千个组件，300 万个连接点以及 800 多公里长的导线组成。并且，为了保持它内部的机械装置同步，有一个 15 米长的连接杆将其连接起来，并由一台 5 马力的电机来驱动。 哈佛马克一号的左边部分 哈佛马克一号的右边部分 机电计算机的大脑是继电器，这是一种电控制器件，当接通控制电流的电路的时候，会控制继电器中的机械臂闭合电路，从而使目标器件通电。在机电计算机中，利用继电器来控制电机的运动，来完成计算的目的。 继电器工作原理 然而继电器中的机械臂是有质量的，这导致其无法快速翻转。在 1940 年代，一个好的继电器大概每秒能翻转 50 次左右。在哈佛马克一号上，1 秒钟大约能做 3 次加法，乘法需要 6 秒，除法则需要 15 秒，而做类似三角函数的复杂计算需要的时间达到了 1 分钟以上。 另外，继电器是也是一种机械设备，那么机械的磨损也不可避免，而继电器的损坏会直接造成计算错误。在哈佛马克一号中大约有 3500 个继电器，即使每个继电器的寿命能达到 10 年，平均每天都需要更换一个继电器。 最后，大型机电计算机持续地运转，造成机器温度较高，而吸引了许多昆虫。当时的工作人员排除计算机故障时，从中拖出了大量的死虫子（bug），这也是计算机术语 “bug” 的由来。 电子计算机的开端机电计算机的弊端和上限，让人们必须去寻找更快速稳定的计算机器。还好，科学家们早有准备，John Ambrose Fleming 早在 1904 年就发明了热电子管。 电子管是一种玻璃制成的真空管。把两个电极放在真空管中，其中一个电极可以加热，从而发射电子，让另一个电极带上正电荷吸引电子，就可以形成电流，这种让电子单向流动部件就叫做二极管。 但是如果要用于计算，我们还需要控制电流的开关。Lee de Forest 1906 年在二极管之间加入了控制电极，制作出了三极管。如果向控制电极施加正电荷，则电子就会流动，反之如果施加负电荷，则会阻止电子流动，用于达到控制电路闭合或断开的功能。 电子三极管原理 电子管内没有“机械臂”的运动，减少了磨损，并大大提高了速度，它每秒可以闭合断开电路数千次。电子管逐步运用到计算机中，标志着电子计算机的开端。 1943 年 12 月，Tommy Flowers 设计出了第一个用真空管的计算机“巨人一号”，在英国的“布莱切利园”用于破解纳粹通信密码。它采用了 1600 个真空管，通过插入预先设置好的程序板来进行计算，被认为是第一个可编程的计算机。顺便提一下，两年前，Alan Mathison Turing（阿兰·图灵）也在同一个地方用机电计算机“BOMBE”破解纳粹的英格玛密码。 而 1946 年在宾夕法尼亚大学制造的电子数值积分计算机“ENIAC”，则被认为是第一个真正通用，可编程的电子计算机。它每秒可以进行 5000 次十位数加减法，据统计，在它运行的 10 年中，计算量比之前全人类加起来的计算量都多。 ENIAC 电子管作为电子计算机及各类电子器件的基础，持续了半个世纪之久。然而电子管也有很大的缺陷：它脆弱易碎，并且像灯泡一样会烧坏。在 ENIAC 中，因为电子管的数量巨大，平均每半天就会有一个电子管被烧坏。 现代电子计算机的基础为了进一步降低计算成本，提高计算的可靠性，人们还需要一种新的电子开关。直到 1947 年，贝尔实验室的科学家们发明了晶体管。 晶体管也是一种电子开关，它有两个电极，电极中间有一层有时导电，有时不导电，因此被称为半导体的材料。通过加入一个“门电极”，通过改变门电极上的电荷，我们可以控制半导体材料的导电性，来开关电路。 晶体三极管工作方式 贝尔实验室的第一个晶体管每秒就可以开关上万次。而且，比起玻璃制成的电子管，晶体管是固态的。同时，比起电子管来说，晶体管的体积远远比电子管小，导致了更小更便宜并且更稳定的计算机成为了可能。 电子管（左）与晶体管（右）对比 IBM 1957 年制造出来的 IBM608 是第一个完全采用晶体管制造的计算机。它大约采用了 3000 个晶体管，每秒钟可以进行 4500 次加减法或 80 次乘除法的运算。 IBM 608 IBM 很快把所有的产品都采用了晶体管，大大减小计算机的体积和价格，使计算机逐渐进入了办公室与家庭。 如今，晶体管的普遍体积均小于 50 纳米，甚至可以达到 7 纳米的程度（要知道一张纸的厚度大概等于 10 万纳米！），并且每秒至少能切换上百万次。 因为很多开发半导体与晶体管的公司在加州的“圣克拉拉谷”，而生产半导体的常见材料是硅，所以人们把这里称为“硅谷”。William Shockly 搬到这里，创立了“肖克利半导体”，里面的员工后来成立了“仙童半导体”，仙童半导体里面的员工后来创立出了“英特尔”——当今世界上最大的计算机芯片制造商。 之后从继电器到电子管再到晶体管，我们让计算机的控制部分变得非常地快，并且大大减少了体积和成本。但我们如何用晶体管代替机械设备来做运算，从而减少机械磨损呢？我们在接下来解释这个问题。","link":"/article/theory/electronic-computer/"}],"tags":[{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Wiki","slug":"Wiki","link":"/tags/Wiki/"},{"name":"community","slug":"community","link":"/tags/community/"},{"name":"guide","slug":"guide","link":"/tags/guide/"},{"name":"university","slug":"university","link":"/tags/university/"},{"name":"开源","slug":"开源","link":"/tags/%E5%BC%80%E6%BA%90/"},{"name":"展览","slug":"展览","link":"/tags/%E5%B1%95%E8%A7%88/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"full-stack","slug":"full-stack","link":"/tags/full-stack/"},{"name":"重庆","slug":"重庆","link":"/tags/%E9%87%8D%E5%BA%86/"},{"name":"offline","slug":"offline","link":"/tags/offline/"},{"name":"Deno","slug":"Deno","link":"/tags/Deno/"},{"name":"Chrome","slug":"Chrome","link":"/tags/Chrome/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"performance","slug":"performance","link":"/tags/performance/"},{"name":"Google","slug":"Google","link":"/tags/Google/"},{"name":"pair-programming","slug":"pair-programming","link":"/tags/pair-programming/"},{"name":"GitHub","slug":"GitHub","link":"/tags/GitHub/"},{"name":"product","slug":"product","link":"/tags/product/"},{"name":"design","slug":"design","link":"/tags/design/"},{"name":"computer","slug":"computer","link":"/tags/computer/"},{"name":"science","slug":"science","link":"/tags/science/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"online","slug":"online","link":"/tags/online/"},{"name":"RESTful","slug":"RESTful","link":"/tags/RESTful/"},{"name":"WebCell","slug":"WebCell","link":"/tags/WebCell/"},{"name":"Strapi","slug":"Strapi","link":"/tags/Strapi/"},{"name":"teenager","slug":"teenager","link":"/tags/teenager/"},{"name":"debug","slug":"debug","link":"/tags/debug/"},{"name":"functional-programming","slug":"functional-programming","link":"/tags/functional-programming/"},{"name":"front-end","slug":"front-end","link":"/tags/front-end/"},{"name":"freeCodeCamp","slug":"freeCodeCamp","link":"/tags/freeCodeCamp/"},{"name":"translation","slug":"translation","link":"/tags/translation/"},{"name":"english","slug":"english","link":"/tags/english/"},{"name":"Node.JS","slug":"Node-JS","link":"/tags/Node-JS/"},{"name":"crawler","slug":"crawler","link":"/tags/crawler/"},{"name":"Puppeteer","slug":"Puppeteer","link":"/tags/Puppeteer/"},{"name":"cooperation","slug":"cooperation","link":"/tags/cooperation/"},{"name":"AI","slug":"AI","link":"/tags/AI/"},{"name":"WeChat","slug":"WeChat","link":"/tags/WeChat/"},{"name":"robot","slug":"robot","link":"/tags/robot/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"component","slug":"component","link":"/tags/component/"},{"name":"BootStrap","slug":"BootStrap","link":"/tags/BootStrap/"},{"name":"文言","slug":"文言","link":"/tags/%E6%96%87%E8%A8%80/"},{"name":"TDD","slug":"TDD","link":"/tags/TDD/"},{"name":"Agile","slug":"Agile","link":"/tags/Agile/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"二叉树","slug":"二叉树","link":"/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"Bronze-3","slug":"Bronze-3","link":"/tags/Bronze-3/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"堆栈","slug":"堆栈","link":"/tags/%E5%A0%86%E6%A0%88/"},{"name":"ECMAScript","slug":"ECMAScript","link":"/tags/ECMAScript/"},{"name":"DOM","slug":"DOM","link":"/tags/DOM/"},{"name":"BOM","slug":"BOM","link":"/tags/BOM/"},{"name":"API","slug":"API","link":"/tags/API/"},{"name":"Codespaces","slug":"Codespaces","link":"/tags/Codespaces/"},{"name":"GraphQL","slug":"GraphQL","link":"/tags/GraphQL/"},{"name":"Apollo","slug":"Apollo","link":"/tags/Apollo/"},{"name":"Koa","slug":"Koa","link":"/tags/Koa/"},{"name":"MongoDB","slug":"MongoDB","link":"/tags/MongoDB/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"bundle","slug":"bundle","link":"/tags/bundle/"},{"name":"mentor","slug":"mentor","link":"/tags/mentor/"},{"name":"workshop","slug":"workshop","link":"/tags/workshop/"},{"name":"NGO","slug":"NGO","link":"/tags/NGO/"},{"name":"college","slug":"college","link":"/tags/college/"},{"name":"PWA","slug":"PWA","link":"/tags/PWA/"},{"name":"conference","slug":"conference","link":"/tags/conference/"},{"name":"Open-Source","slug":"Open-Source","link":"/tags/Open-Source/"},{"name":"hardware","slug":"hardware","link":"/tags/hardware/"},{"name":"binary","slug":"binary","link":"/tags/binary/"},{"name":"logic","slug":"logic","link":"/tags/logic/"},{"name":"circuit","slug":"circuit","link":"/tags/circuit/"},{"name":"history","slug":"history","link":"/tags/history/"}],"categories":[{"name":"Open-Source","slug":"Open-Source","link":"/categories/Open-Source/"},{"name":"Partner","slug":"Partner","link":"/categories/Partner/"},{"name":"Profile","slug":"Profile","link":"/categories/Profile/"},{"name":"Activity","slug":"Activity","link":"/categories/Activity/"},{"name":"Conference","slug":"Activity/Conference","link":"/categories/Activity/Conference/"},{"name":"Salon","slug":"Activity/Salon","link":"/categories/Activity/Salon/"},{"name":"Workshop","slug":"Activity/Workshop","link":"/categories/Activity/Workshop/"},{"name":"Article","slug":"Article","link":"/categories/Article/"},{"name":"Algorithm","slug":"Article/Algorithm","link":"/categories/Article/Algorithm/"},{"name":"Engineering","slug":"Article/Engineering","link":"/categories/Article/Engineering/"},{"name":"Propaganda","slug":"Article/Propaganda","link":"/categories/Article/Propaganda/"},{"name":"Summary","slug":"Article/Summary","link":"/categories/Article/Summary/"},{"name":"Theory","slug":"Article/Theory","link":"/categories/Article/Theory/"}]}